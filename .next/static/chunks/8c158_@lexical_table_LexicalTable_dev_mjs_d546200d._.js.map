{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Btable%400.33.1/node_modules/%40lexical/table/LexicalTable.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $descendantsMatching, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement as isHTMLElement$1, $insertFirst as $insertFirst$1, mergeRegister, $insertNodeToNearestRoot, $unwrapAndFilterDescendants } from '@lexical/utils';\nimport { ElementNode, isHTMLElement, $isInlineElementOrDecoratorNode, $isTextNode, $isLineBreakNode, $createParagraphNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $isParagraphNode, $createPoint, $isElementNode, $normalizeSelection__EXPERIMENTAL, isCurrentlyReadOnlyMode, TEXT_TYPE_TO_FORMAT, $getNodeByKey, $getEditor, $setSelection, SELECTION_CHANGE_COMMAND, getDOMSelection, $createRangeSelection, $isRootNode, INSERT_PARAGRAPH_COMMAND, COMMAND_PRIORITY_HIGH, KEY_ESCAPE_COMMAND, COMMAND_PRIORITY_CRITICAL, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $getNearestNodeFromDOMNode, $createRangeSelectionFromDom, $isRootOrShadowRoot, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, isDOMNode, $caretFromPoint, $isExtendableTextPointCaret, $extendCaretToRange, $isSiblingCaret, $getSiblingCaret, $setPointFromCaret, $normalizeCaret, $getAdjacentChildCaret, $isChildCaret, $getChildCaret, setDOMUnmanaged, COMMAND_PRIORITY_EDITOR, CLICK_COMMAND } from 'lexical';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n    this.__verticalAlign = node.__verticalAlign;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || undefined);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n    this.__verticalAlign = undefined;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    if (isValidVerticalAlign(this.__verticalAlign)) {\n      element.style.verticalAlign = this.__verticalAlign;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if (isHTMLElement(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = this.getVerticalAlign() || 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(isValidVerticalAlign(this.__verticalAlign) && {\n        verticalAlign: this.__verticalAlign\n      }),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  getVerticalAlign() {\n    return this.getLatest().__verticalAlign;\n  }\n  setVerticalAlign(newVerticalAlign) {\n    const self = this.getWritable();\n    self.__verticalAlign = newVerticalAlign || undefined;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction isValidVerticalAlign(verticalAlign) {\n  return verticalAlign === 'middle' || verticalAlign === 'bottom';\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const verticalAlign = domNode_.style.verticalAlign;\n  if (isValidVerticalAlign(verticalAlign)) {\n    tableCellNode.__verticalAlign = verticalAlign;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      const result = [];\n      let paragraphNode = null;\n      const removeSingleLineBreakNode = () => {\n        if (paragraphNode) {\n          const firstChild = paragraphNode.getFirstChild();\n          if ($isLineBreakNode(firstChild) && paragraphNode.getChildrenSize() === 1) {\n            firstChild.remove();\n          }\n        }\n      };\n      for (const child of childLexicalNodes) {\n        if ($isInlineElementOrDecoratorNode(child) || $isTextNode(child) || $isLineBreakNode(child)) {\n          if ($isTextNode(child)) {\n            if (hasBoldFontWeight) {\n              child.toggleFormat('bold');\n            }\n            if (hasLinethroughTextDecoration) {\n              child.toggleFormat('strikethrough');\n            }\n            if (hasItalicFontStyle) {\n              child.toggleFormat('italic');\n            }\n            if (hasUnderlineTextDecoration) {\n              child.toggleFormat('underline');\n            }\n          }\n          if (paragraphNode) {\n            paragraphNode.append(child);\n          } else {\n            paragraphNode = $createParagraphNode().append(child);\n            result.push(paragraphNode);\n          }\n        } else {\n          result.push(child);\n          removeSingleLineBreakNode();\n          paragraphNode = null;\n        }\n      }\n      removeSingleLineBreakNode();\n      if (result.length === 0) {\n        result.push($createParagraphNode());\n      }\n      return result;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableRowAtSelection} or {@link $insertTableRowAtNode} instead.\n */\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtSelection(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableRowAtSelection}\n */\nconst $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;\n\n/**\n * Inserts a table row before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtNode(cellNode, insertAfter = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: cellStartRow\n  } = cellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      formatDevErrorMessage(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = cellStartRow;\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      formatDevErrorMessage(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableColumnAtSelection} or {@link $insertTableColumnAtNode} instead.\n */\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtSelection(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableColumnAtSelection}\n */\nconst $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;\n\n/**\n * Inserts a column before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const rowCount = gridMap.length;\n  const {\n    startColumn\n  } = cellMap;\n  const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    formatDevErrorMessage(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        formatDevErrorMessage(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null && shouldSetSelection) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $deleteTableColumnAtSelection} instead.\n */\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRowAtSelection() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top or bottom have to be trimmed\n      if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        const intersectionStart = Math.max(cellStartRow, anchorStartRow);\n        const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);\n        const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;\n        cell.setRowSpan(cell.__rowSpan - overflowRowsCount);\n      }\n      // Rows overflowing bottom have to be moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow &&\n      // Handle overflow only once\n      row === focusEndRow) {\n        if (!(nextRowNode !== null)) {\n          formatDevErrorMessage(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableRowAtSelection}\n */\nconst $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;\nfunction $deleteTableColumnAtSelection() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableColumnAtSelection}\n */\nconst $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $mergeCells(cellNodes) {\n  if (cellNodes.length === 0) {\n    return null;\n  }\n\n  // Find the table node\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);\n  const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);\n\n  // Find the boundaries of the selection including merged cells\n  let minRow = Infinity;\n  let maxRow = -Infinity;\n  let minCol = Infinity;\n  let maxCol = -Infinity;\n\n  // First pass: find the actual boundaries considering merged cells\n  const processedCells = new Set();\n  for (const row of gridMap) {\n    for (const mapCell of row) {\n      if (!mapCell || !mapCell.cell) {\n        continue;\n      }\n      const cellKey = mapCell.cell.getKey();\n      if (processedCells.has(cellKey)) {\n        continue;\n      }\n      if (cellNodes.some(cell => cell.is(mapCell.cell))) {\n        processedCells.add(cellKey);\n        // Get the actual position of this cell in the grid\n        const cellStartRow = mapCell.startRow;\n        const cellStartCol = mapCell.startColumn;\n        const cellRowSpan = mapCell.cell.__rowSpan || 1;\n        const cellColSpan = mapCell.cell.__colSpan || 1;\n\n        // Update boundaries considering the cell's actual position and span\n        minRow = Math.min(minRow, cellStartRow);\n        maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);\n        minCol = Math.min(minCol, cellStartCol);\n        maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);\n      }\n    }\n  }\n\n  // Validate boundaries\n  if (minRow === Infinity || minCol === Infinity) {\n    return null;\n  }\n\n  // The total span of the merged cell\n  const totalRowSpan = maxRow - minRow + 1;\n  const totalColSpan = maxCol - minCol + 1;\n\n  // Use the top-left cell as the target cell\n  const targetCellMap = gridMap[minRow][minCol];\n  if (!targetCellMap.cell) {\n    return null;\n  }\n  const targetCell = targetCellMap.cell;\n\n  // Set the spans for the target cell\n  targetCell.setColSpan(totalColSpan);\n  targetCell.setRowSpan(totalRowSpan);\n\n  // Move content from other cells to the target cell\n  const seenCells = new Set([targetCell.getKey()]);\n\n  // Second pass: merge content and remove other cells\n  for (let row = minRow; row <= maxRow; row++) {\n    for (let col = minCol; col <= maxCol; col++) {\n      const mapCell = gridMap[row][col];\n      if (!mapCell.cell) {\n        continue;\n      }\n      const currentCell = mapCell.cell;\n      const key = currentCell.getKey();\n      if (!seenCells.has(key)) {\n        seenCells.add(key);\n        const isEmpty = $cellContainsEmptyParagraph(currentCell);\n        if (!isEmpty) {\n          targetCell.append(...currentCell.getChildren());\n        }\n        currentCell.remove();\n      }\n    }\n  }\n\n  // Ensure target cell has content\n  if (targetCell.getChildrenSize() === 0) {\n    targetCell.append($createParagraphNode());\n  }\n  return targetCell;\n}\nfunction $cellContainsEmptyParagraph(cell) {\n  if (cell.getChildrenSize() !== 1) {\n    return false;\n  }\n  const firstChild = cell.getFirstChildOrThrow();\n  if (!$isParagraphNode(firstChild) || !firstChild.isEmpty()) {\n    return false;\n  }\n  return true;\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const cellNode = $findMatchingParent(anchor, $isTableCellNode);\n  if (!$isTableCellNode(cellNode)) {\n    formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n  }\n  return $unmergeCellNode(cellNode);\n}\nfunction $unmergeCellNode(cellNode) {\n  const [cell, row, grid] = $getNodeTriplet(cellNode);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        formatDevErrorMessage(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    formatDevErrorMessage(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    formatDevErrorMessage(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      formatDevErrorMessage(`Expected TableNode children to be TableRowNode`);\n    }\n    const startMapRow = getMapRow(rowIdx);\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        formatDevErrorMessage(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    formatDevErrorMessage(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    formatDevErrorMessage(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  // Initial boundaries based on the anchor and focus cells\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n\n  // Keep expanding until we have a complete rectangle\n  let hasChanges;\n  do {\n    hasChanges = false;\n\n    // Check all cells in the table\n    for (let row = 0; row < map.length; row++) {\n      for (let col = 0; col < map[0].length; col++) {\n        const cell = map[row][col];\n        if (!cell) {\n          continue;\n        }\n        const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;\n        const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;\n\n        // Check if this cell intersects with our current selection rectangle\n        const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;\n        const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;\n\n        // If the cell intersects either horizontally or vertically\n        if (intersectsHorizontally && intersectsVertically) {\n          // Expand boundaries to include this cell completely\n          const newMinColumn = Math.min(minColumn, cell.startColumn);\n          const newMaxColumn = Math.max(maxColumn, cellEndCol);\n          const newMinRow = Math.min(minRow, cell.startRow);\n          const newMaxRow = Math.max(maxRow, cellEndRow);\n\n          // Check if boundaries changed\n          if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {\n            minColumn = newMinColumn;\n            maxColumn = newMaxColumn;\n            minRow = newMinRow;\n            maxRow = newMaxRow;\n            hasChanges = true;\n          }\n        }\n      }\n    }\n  } while (hasChanges);\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = $findMatchingParent(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    formatDevErrorMessage(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    return this.tableKey !== 'root' && this.anchor.key !== 'root' && this.anchor.type === 'element' && this.focus.key !== 'root' && this.focus.type === 'element';\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, $createPoint(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ($isParagraphNode(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      formatDevErrorMessage(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          formatDevErrorMessage(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          formatDevErrorMessage(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          formatDevErrorMessage(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required arguments and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      formatDevErrorMessage(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = $getSelection();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && $isElementNode(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = $getEditor()) {\n  const tableNode = $getNodeByKey(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    formatDevErrorMessage(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.pointerType = null;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ($getSelection() !== null) {\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    addClassNamesToElement(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        formatDevErrorMessage(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = getDOMSelection(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if triggered from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        $setSelection(this.tableSelection);\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? $getNodeByKey(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? $getNodeByKey(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected Table selection`);\n    }\n    const formatSelection = $createRangeSelection();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      formatDevErrorMessage(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = $isParagraphNode(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    $setSelection(selection);\n    this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = $getNodeByKey(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n    // Check if the entire table is selected by verifying first and last cells\n    const firstRow = tableNode.getFirstChild();\n    const lastRow = tableNode.getLastChild();\n    const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();\n    if (isEntireTableSelected) {\n      tableNode.selectPrevious();\n      const parent = tableNode.getParent();\n      // Delete entire table\n      tableNode.remove();\n      // Handle case when table was the only node\n      if ($isRootNode(parent) && parent.isEmpty()) {\n        editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n      }\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ($isElementNode(cellNode)) {\n        const paragraphNode = $createParagraphNode();\n        const textNode = $createTextNode();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    $setSelection(null);\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isPointerDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction isHTMLTableElement(el) {\n  return isHTMLElement(el) && el.nodeName === 'TABLE';\n}\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = isHTMLTableElement(dom) ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    formatDevErrorMessage(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[KEY_ARROW_DOWN_COMMAND, 'down'], [KEY_ARROW_UP_COMMAND, 'up'], [KEY_ARROW_LEFT_COMMAND, 'backward'], [KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    formatDevErrorMessage(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));\n  const createPointerHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onPointerUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('pointerup', onPointerUp);\n      editorWindow.removeEventListener('pointermove', onPointerMove);\n    };\n    const onPointerMove = moveEvent => {\n      if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('pointerup', onPointerUp);\n        editorWindow.removeEventListener('pointermove', onPointerMove);\n        return;\n      }\n      if (!isDOMNode(moveEvent.target)) {\n        return;\n      }\n      let focusCell = null;\n      // In firefox the moveEvent.target may be captured so we must always\n      // consult the coordinates #7245\n      const override = !(IS_FIREFOX || tableElement.contains(moveEvent.target));\n      if (override) {\n        focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = getDOMCellInTableFromTarget(tableElement, el);\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('pointerup', onPointerUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('pointermove', onPointerMove, tableObserver.listenerOptions);\n  };\n  const onPointerDown = event => {\n    tableObserver.pointerType = event.pointerType;\n    if (event.button !== 0 || !isDOMNode(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = $getPreviousSelection();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ($isRangeSelection(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          // Only set anchor cell for selection if this is not a simple touch tap\n          // Touch taps should not initiate table selection mode\n          if (event.pointerType !== 'touch') {\n            tableObserver.$setAnchorCellForSelection(targetCell);\n          }\n        }\n      });\n    }\n    createPointerHandlers();\n  };\n  tableElement.addEventListener('pointerdown', onPointerDown, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('pointerdown', onPointerDown);\n  });\n  const onTripleClick = event => {\n    if (event.detail >= 3 && isDOMNode(event.target)) {\n      const targetCell = getDOMCellFromTarget(event.target);\n      if (targetCell !== null) {\n        event.preventDefault();\n      }\n    }\n  };\n  tableElement.addEventListener('mousedown', onTripleClick, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('mousedown', onTripleClick);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const pointerDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !isDOMNode(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('pointerdown', pointerDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    editorWindow.removeEventListener('pointerdown', pointerDownCallback);\n  });\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  }\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n\n    // Align the table if the entire table is selected\n    if ($isFullTableSelection(selection, tableNode)) {\n      tableNode.setFormat(formatType);\n      return true;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (selectionPayload, dispatchEditor) => {\n    if (editor !== dispatchEditor) {\n      return false;\n    }\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor, focus] = anchorAndFocus;\n    const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);\n    const focusCellNode = $findMatchingParent(focus.getNode(), n => $isTableCellNode(n));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const templateGrid = nodes[0];\n    const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);\n    const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);\n    const initialRowCount = initialGridMap.length;\n    const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;\n\n    // If we have a range selection, we'll fit the template grid into the\n    // table, growing the table if necessary.\n    let startRow = anchorCellMap.startRow;\n    let startCol = anchorCellMap.startColumn;\n    let affectedRowCount = templateGridMap.length;\n    let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;\n    if (isTableSelection) {\n      // If we have a table selection, we'll only modify the cells within\n      // the selection boundary.\n      const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);\n      const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;\n      const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;\n      startRow = selectionBoundary.minRow;\n      startCol = selectionBoundary.minColumn;\n      affectedRowCount = Math.min(affectedRowCount, selectionRowCount);\n      affectedColCount = Math.min(affectedColCount, selectionColCount);\n    }\n\n    // Step 1: Unmerge all merged cells within the affected area\n    let didPerformMergeOperations = false;\n    const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;\n    const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;\n    const unmergedKeys = new Set();\n    for (let row = startRow; row <= lastRowForUnmerge; row++) {\n      for (let col = startCol; col <= lastColForUnmerge; col++) {\n        const cellMap = initialGridMap[row][col];\n        if (unmergedKeys.has(cellMap.cell.getKey())) {\n          continue; // cell was a merged cell that was already handled\n        }\n        if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {\n          continue; // cell is not a merged cell\n        }\n        $unmergeCellNode(cellMap.cell);\n        unmergedKeys.add(cellMap.cell.getKey());\n        didPerformMergeOperations = true;\n      }\n    }\n    let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 2: Expand current table (if needed)\n    const rowsToInsert = affectedRowCount - initialRowCount + startRow;\n    for (let i = 0; i < rowsToInsert; i++) {\n      const cellMap = interimGridMap[initialRowCount - 1][0];\n      $insertTableRowAtNode(cellMap.cell);\n    }\n    const colsToInsert = affectedColCount - initialColCount + startCol;\n    for (let i = 0; i < colsToInsert; i++) {\n      const cellMap = interimGridMap[0][initialColCount - 1];\n      $insertTableColumnAtNode(cellMap.cell, true, false);\n    }\n    [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 3: Merge cells and set cell content, to match template grid\n    for (let row = startRow; row < startRow + affectedRowCount; row++) {\n      for (let col = startCol; col < startCol + affectedColCount; col++) {\n        const templateRow = row - startRow;\n        const templateCol = col - startCol;\n        const templateCellMap = templateGridMap[templateRow][templateCol];\n        if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {\n          continue; // cell is a merged cell that was already handled\n        }\n        const templateCell = templateCellMap.cell;\n        if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {\n          const cellsToMerge = [];\n          const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;\n          const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;\n          for (let r = row; r <= lastRowForMerge; r++) {\n            for (let c = col; c <= lastColForMerge; c++) {\n              const cellMap = interimGridMap[r][c];\n              cellsToMerge.push(cellMap.cell);\n            }\n          }\n          $mergeCells(cellsToMerge);\n          didPerformMergeOperations = true;\n        }\n        const {\n          cell\n        } = interimGridMap[row][col];\n        const originalChildren = cell.getChildren();\n        templateCell.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            cell.append(child);\n          } else {\n            cell.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n      }\n    }\n    if (isTableSelection && didPerformMergeOperations) {\n      // reset the table selection in case the anchor or focus cell was\n      // removed via merge operations\n      const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n      const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];\n      newAnchorCellMap.cell.selectEnd();\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && $isRangeSelection(prevSelection) && $isRangeSelection(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is($findMatchingParent(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n\n        // Handle case when the pointer type is touch and the current and\n        // previous selection are collapsed, and the previous anchor and current\n        // focus cell nodes are different, then we convert it into table selection\n        // However, only do this if the table observer is actively selecting (user dragging)\n        // to prevent unwanted selections when simply tapping between cells on mobile\n        if (tableObserver.pointerType === 'touch' && tableObserver.isSelecting && selection.isCollapsed() && $isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());\n          if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));\n            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n            tableObserver.pointerType = null;\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction detachTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    formatDevErrorMessage(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getDOMCellInTableFromTarget(table, node) {\n  if (!table.contains(node)) {\n    return null;\n  }\n  let cell = null;\n  for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {\n    if (currentNode === table) {\n      return cell;\n    }\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      cell = currentNode._cell || null;\n    }\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ($isElementNode(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = $findMatchingParent(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ($isElementNode(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = $findMatchingParent(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    formatDevErrorMessage(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    // TODO this should probably return false if there's an unrelated\n    //      shadow root between the node and the table (e.g. another table,\n    //      collapsible, etc.)\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction $isFullTableSelection(selection, tableNode) {\n  if ($isTableSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (tableNode && anchorNode && focusNode) {\n      const [map] = $computeTableMap(tableNode, anchorNode, focusNode);\n      return anchorNode.getKey() === map[0][0].cell.getKey() && focusNode.getKey() === map[map.length - 1].at(-1).cell.getKey();\n    }\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  addClassNamesToElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  removeClassNamesFromElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ($isElementNode(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {\n  const initialFocus = $caretFromPoint(selection.focus, isBackward ? 'previous' : 'next');\n  if ($isExtendableTextPointCaret(initialFocus)) {\n    return false;\n  }\n  let lastCaret = initialFocus;\n  // TableCellNode is the only shadow root we are interested in piercing so\n  // we find the last internal caret and then check its parent\n  for (const nextCaret of $extendCaretToRange(initialFocus).iterNodeCarets('shadowRoot')) {\n    if (!($isSiblingCaret(nextCaret) && $isElementNode(nextCaret.origin))) {\n      return false;\n    }\n    lastCaret = nextCaret;\n  }\n  const lastCaretParent = lastCaret.getParentAtCaret();\n  if (!$isTableCellNode(lastCaretParent)) {\n    return false;\n  }\n  const anchorCell = lastCaretParent;\n  const focusCaret = $findNextTableCell($getSiblingCaret(anchorCell, lastCaret.direction));\n  const anchorCellTable = $findMatchingParent(anchorCell, $isTableNode);\n  if (!(anchorCellTable && anchorCellTable.is(tableNode))) {\n    return false;\n  }\n  const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());\n  const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);\n  if (!anchorCellDOM || !anchorDOMCell) {\n    return false;\n  }\n  const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);\n  tableObserver.table = anchorCellTableElement;\n  if (!focusCaret) {\n    if (alter === 'extend') {\n      // extend the selection from a range inside the cell to a table selection of the cell\n      tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n      tableObserver.$setFocusCellForSelection(anchorDOMCell, true);\n    } else {\n      // exit the table\n      const outerFocusCaret = $getTableExitCaret($getSiblingCaret(anchorCellTable, initialFocus.direction));\n      $setPointFromCaret(selection.anchor, outerFocusCaret);\n      $setPointFromCaret(selection.focus, outerFocusCaret);\n    }\n  } else if (alter === 'extend') {\n    const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));\n    if (!focusDOMCell) {\n      return false;\n    }\n    tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n    tableObserver.$setFocusCellForSelection(focusDOMCell, true);\n  } else {\n    // alter === 'move'\n    const innerFocusCaret = $normalizeCaret(focusCaret);\n    $setPointFromCaret(selection.anchor, innerFocusCaret);\n    $setPointFromCaret(selection.focus, innerFocusCaret);\n  }\n  stopEvent(event);\n  return true;\n}\nfunction $getTableExitCaret(initialCaret) {\n  const adjacent = $getAdjacentChildCaret(initialCaret);\n  return $isChildCaret(adjacent) ? $normalizeCaret(adjacent) : initialCaret;\n}\nfunction $findNextTableCell(initialCaret) {\n  for (const nextCaret of $extendCaretToRange(initialCaret).iterNodeCarets('root')) {\n    const {\n      origin\n    } = nextCaret;\n    if ($isTableCellNode(origin)) {\n      // not sure why ts isn't narrowing here (even if the guard is on nextCaret.origin)\n      // but returning a new caret is fine\n      if ($isChildCaret(nextCaret)) {\n        return $getChildCaret(origin, initialCaret.direction);\n      }\n    } else if (!$isTableRowNode(origin)) {\n      break;\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = $isTextNode(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode(newFocusNode) ? 'text' : 'element');\n          $setSelection(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection)) {\n    if (direction === 'backward' || direction === 'forward') {\n      const alter = event.shiftKey ? 'extend' : 'move';\n      return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === 'backward', tableNode, tableObserver);\n    }\n    if (selection.isCollapsed()) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n      const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n      if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n        return false;\n      }\n      const anchorCellTable = $findTableNode(anchorCellNode);\n      if (anchorCellTable !== tableNode && anchorCellTable != null) {\n        const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n        if (anchorCellTableElement != null) {\n          tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n          return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n        }\n      }\n      const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n      const anchorDOM = editor.getElementByKey(anchor.key);\n      if (anchorDOM == null || anchorCellDom == null) {\n        return false;\n      }\n      let edgeSelectionRect;\n      if (anchor.type === 'element') {\n        edgeSelectionRect = anchorDOM.getBoundingClientRect();\n      } else {\n        const domSelection = getDOMSelection(getEditorWindow(editor));\n        if (domSelection === null || domSelection.rangeCount === 0) {\n          return false;\n        }\n        const range = domSelection.getRangeAt(0);\n        edgeSelectionRect = range.getBoundingClientRect();\n      }\n      const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n      if (edgeChild == null) {\n        return false;\n      }\n      const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n      if (edgeChildDOM == null) {\n        return false;\n      }\n      const edgeRect = edgeChildDOM.getBoundingClientRect();\n      const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n      if (isExiting) {\n        stopEvent(event);\n        const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n        if (event.shiftKey) {\n          const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n          tableObserver.$setAnchorCellForSelection(cell);\n          tableObserver.$setFocusCellForSelection(cell, true);\n        } else {\n          return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n        }\n        return true;\n      }\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      formatDevErrorMessage(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = getDOMSelection(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode(startingDOM, editorState));\n}\n\nfunction isHTMLDivElement(element) {\n  return isHTMLElement$1(element) && element.nodeName === 'DIV';\n}\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    addClassNamesToElement(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nfunction setFrozenColumns(dom, tableElement, config, frozenColumnCount) {\n  if (frozenColumnCount > 0) {\n    addClassNamesToElement(dom, config.theme.tableFrozenColumn);\n    tableElement.setAttribute('data-lexical-frozen-column', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableFrozenColumn);\n    tableElement.removeAttribute('data-lexical-frozen-column');\n  }\n}\nfunction setFrozenRows(dom, tableElement, config, frozenRowCount) {\n  if (frozenRowCount > 0) {\n    addClassNamesToElement(dom, config.theme.tableFrozenRow);\n    tableElement.setAttribute('data-lexical-frozen-row', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableFrozenRow);\n    tableElement.removeAttribute('data-lexical-frozen-row');\n  }\n}\nfunction alignTableElement(dom, config, formatType) {\n  if (!config.theme.tableAlignment) {\n    return;\n  }\n  const removeClasses = [];\n  const addClasses = [];\n  for (const format of ['center', 'right']) {\n    const classes = config.theme.tableAlignment[format];\n    if (!classes) {\n      continue;\n    }\n    (format === formatType ? addClasses : removeClasses).push(classes);\n  }\n  removeClassNamesFromElement(dom, ...removeClasses);\n  addClassNamesToElement(dom, ...addClasses);\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = $getEditor()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n    this.__frozenColumnCount = prevNode.__frozenColumnCount;\n    this.__frozenRowCount = prevNode.__frozenRowCount;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n    this.__frozenColumnCount = 0;\n    this.__frozenRowCount = 0;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : undefined,\n      frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : undefined,\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = !isHTMLTableElement(element) ? element.querySelector('table') : element;\n    if (!isHTMLTableElement(tableElement)) {\n      formatDevErrorMessage(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    if (this.__style) {\n      tableElement.style.cssText = this.__style;\n    }\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    setDOMUnmanaged(colGroup);\n    addClassNamesToElement(tableElement, config.theme.table);\n    this.updateTableElement(null, tableElement, config);\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        addClassNamesToElement(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      this.updateTableWrapper(null, wrapperElement, tableElement, config);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateTableWrapper(prevNode, tableWrapper, tableElement, config) {\n    if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {\n      setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);\n    }\n    if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {\n      setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);\n    }\n  }\n  updateTableElement(prevNode, tableElement, config) {\n    if (this.__style !== (prevNode ? prevNode.__style : '')) {\n      tableElement.style.cssText = this.__style;\n    }\n    if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {\n      setRowStriping(tableElement, config, this.__rowStriping);\n    }\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    alignTableElement(tableElement, config, this.getFormatType());\n  }\n  updateDOM(prevNode, dom, config) {\n    const slot = this.getDOMSlot(dom);\n    const tableElement = slot.element;\n    if (dom === tableElement === $isScrollableTablesActive()) {\n      return true;\n    }\n    if (isHTMLDivElement(dom)) {\n      this.updateTableWrapper(prevNode, dom, tableElement, config);\n    }\n    this.updateTableElement(prevNode, tableElement, config);\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (!isHTMLTableElement(tableElement) && isHTMLElement$1(tableElement)) {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLTableElement(tableElement)) {\n          return null;\n        }\n        alignTableElement(tableElement, editor._config, this.getFormatType());\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: !isHTMLTableElement(element) && isHTMLElement$1(element) ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  setFrozenColumns(columnCount) {\n    const self = this.getWritable();\n    self.__frozenColumnCount = columnCount;\n    return self;\n  }\n  getFrozenColumns() {\n    return this.getLatest().__frozenColumnCount;\n  }\n  setFrozenRows(rowCount) {\n    const self = this.getWritable();\n    self.__frozenRowCount = rowCount;\n    return self;\n  }\n  getFrozenRows() {\n    return this.getLatest().__frozenRowCount;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-column')) {\n    tableNode.setFrozenColumns(1);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-row')) {\n    tableNode.setFrozenRows(1);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if (!selection || !$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // Prevent nested tables by checking if we're already inside a table\n  if ($findTableNode(selection.anchor.getNode())) {\n    return false;\n  }\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  $insertNodeToNearestRoot(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ($isTextNode(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append($createParagraphNode());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    $unwrapAndFilterDescendants(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  $unwrapAndFilterDescendants(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append($createParagraphNode());\n      rowNode.append(newCell);\n    }\n  }\n}\nfunction $tableClickCommand(event) {\n  if (event.detail < 3 || !isDOMNode(event.target)) {\n    return false;\n  }\n  const startNode = $getNearestNodeFromDOMNode(event.target);\n  if (startNode === null) {\n    return false;\n  }\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (blockNode === null) {\n    return false;\n  }\n  const rootNode = blockNode.getParent();\n  if (!$isTableCellNode(rootNode)) {\n    return false;\n  }\n  blockNode.select(0);\n  return true;\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              formatDevErrorMessage(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              $insertFirst$1(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      formatDevErrorMessage(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return mergeRegister(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, ({\n    nodes,\n    selection\n  }, dispatchEditor) => {\n    if (editor !== dispatchEditor || !$isRangeSelection(selection)) {\n      return false;\n    }\n    const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;\n    return isInsideTableCell && nodes.some($isTableNode);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLICK_COMMAND, $tableClickCommand, COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\n\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $createTableSelectionFrom, $deleteTableColumn, $deleteTableColumnAtSelection, $deleteTableColumn__EXPERIMENTAL, $deleteTableRowAtSelection, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableAndElementByKey, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumnAtSelection, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRowAtSelection, $insertTableRow__EXPERIMENTAL, $isScrollableTablesActive, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $mergeCells, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableElement, getTableObserverFromTableElement, registerTableCellUnmergeTransform, registerTablePlugin, registerTableSelectionObserver, setScrollableTablesActive };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}