{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/next%4015.3.3_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_sass%401.89.2/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":";AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,MAAQ;;AAEzC,OAAO;IACL,IAAIF,QAAQC,GAAG,CAACK,uBAA2B,EAAF;;IAczC,OAAO;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1C,IAAIP,QAAQC,GAAG,CAACO,SAAS,eAAE;gBACzBL,OAAOC,OAAO,GAAGC,QAAQ;YAC3B,OAAO;;YAEP;QACF,OAAO;;QAMP;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/next%4015.3.3_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_sass%401.89.2/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-ssr'\n].ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,mNAAyBC,QAAQ,CACxD,YACD,CAACC,kBAAkB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/next%4015.3.3_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_sass%401.89.2/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored['react-ssr'].React\n"],"names":["module","exports","require","vendored","React"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,mNAAyBC,QAAQ,CAAC,YAAY,CAACC,KAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/next%4015.3.3_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_sass%401.89.2/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-ssr'\n].ReactJsxRuntime\n"],"names":["module","exports","require","vendored","ReactJsxRuntime"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,mNAAyBC,QAAQ,CACxD,YACD,CAACC,eAAe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/next%4015.3.3_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_sass%401.89.2/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-dom.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored['react-ssr'].ReactDOM\n"],"names":["module","exports","require","vendored","ReactDOM"],"mappings":";AAAAA,OAAOC,OAAO,GAAGC,QAAQ,mNAAyBC,QAAQ,CAAC,YAAY,CAACC,QAAQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalComposerContext.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { createContext, useContext } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst LexicalComposerContext = /*#__PURE__*/createContext(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = useContext(LexicalComposerContext);\n  if (composerContext == null) {\n    {\n      formatDevErrorMessage(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n  return composerContext;\n}\n\nexport { LexicalComposerContext, createLexicalComposerContext, useLexicalComposerContext };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;AAED;;AAEA;;;;;;CAMC,GAED,qEAAqE;AAErE,SAAS,sBAAsB,OAAO;IACpC,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,yBAAyB,WAAW,GAAE,CAAA,GAAA,yVAAA,CAAA,gBAAa,AAAD,EAAE;AAC1D,SAAS,6BAA6B,MAAM,EAAE,KAAK;IACjD,IAAI,gBAAgB;IACpB,IAAI,UAAU,MAAM;QAClB,gBAAgB,MAAM,CAAC,EAAE;IAC3B;IACA,SAAS;QACP,IAAI,SAAS,MAAM;YACjB,OAAO;QACT;QACA,OAAO,iBAAiB,OAAO,cAAc,QAAQ,KAAK;IAC5D;IACA,OAAO;QACL;IACF;AACF;AACA,SAAS;IACP,MAAM,kBAAkB,CAAA,GAAA,yVAAA,CAAA,aAAU,AAAD,EAAE;IACnC,IAAI,mBAAmB,MAAM;QAC3B;YACE,sBAAsB,CAAC,sFAAsF,CAAC;QAChH;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 113, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalComposer.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { createLexicalComposerContext, LexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { createEditor, $getRoot, $createParagraphNode, $getSelection, HISTORY_MERGE_TAG } from 'lexical';\nimport { useLayoutEffect, useEffect, useMemo } from 'react';\nimport { jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: HISTORY_MERGE_TAG\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = useMemo(() => {\n    const {\n      theme,\n      namespace,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = createLexicalComposerContext(null, theme);\n    const editor = createEditor({\n      editable: initialConfig.editable,\n      html,\n      namespace,\n      nodes,\n      onError: error => onError(error, editor),\n      theme\n    });\n    initializeEditor(editor, initialEditorState);\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/jsx(LexicalComposerContext.Provider, {\n    value: composerContext,\n    children: children\n  });\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = $getRoot();\n      if (root.isEmpty()) {\n        const paragraph = $createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ($getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = $getRoot();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexport { LexicalComposer };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAED;AACA;AACA;AACA;;;;;AAEA;;;;;;CAMC,GAED,MAAM,cAAc,OAAO,WAAW,eAAe,OAAO,OAAO,QAAQ,KAAK,eAAe,OAAO,OAAO,QAAQ,CAAC,aAAa,KAAK;AAExI;;;;;;CAMC,GAGD,sDAAsD;AACtD,wCAAwC;AACxC,+CAA+C;AAC/C,MAAM,sBAAsB,cAAc,yVAAA,CAAA,kBAAe,GAAG,yVAAA,CAAA,YAAS;AAErE;;;;;;CAMC,GAED,MAAM,wBAAwB;IAC5B,KAAK,+LAAA,CAAA,oBAAiB;AACxB;AACA,SAAS,gBAAgB,EACvB,aAAa,EACb,QAAQ,EACT;IACC,MAAM,kBAAkB,CAAA,GAAA,yVAAA,CAAA,UAAO,AAAD,EAAE;QAC9B,MAAM,EACJ,KAAK,EACL,SAAS,EACT,KAAK,EACL,OAAO,EACP,aAAa,kBAAkB,EAC/B,IAAI,EACL,GAAG;QACJ,MAAM,UAAU,CAAA,GAAA,sUAAA,CAAA,+BAA4B,AAAD,EAAE,MAAM;QACnD,MAAM,SAAS,CAAA,GAAA,+LAAA,CAAA,eAAY,AAAD,EAAE;YAC1B,UAAU,cAAc,QAAQ;YAChC;YACA;YACA;YACA,SAAS,CAAA,QAAS,QAAQ,OAAO;YACjC;QACF;QACA,iBAAiB,QAAQ;QACzB,OAAO;YAAC;YAAQ;SAAQ;IAC1B,GACA,2BAA2B;IAC3B,uDAAuD;IACvD,EAAE;IACF,oBAAoB;QAClB,MAAM,aAAa,cAAc,QAAQ;QACzC,MAAM,CAAC,OAAO,GAAG;QACjB,OAAO,WAAW,CAAC,eAAe,YAAY,aAAa;IAE3D,2BAA2B;IAC3B,uDAAuD;IACzD,GAAG,EAAE;IACL,OAAO,WAAW,GAAE,CAAA,GAAA,2WAAA,CAAA,MAAG,AAAD,EAAE,sUAAA,CAAA,yBAAsB,CAAC,QAAQ,EAAE;QACvD,OAAO;QACP,UAAU;IACZ;AACF;AACA,SAAS,iBAAiB,MAAM,EAAE,kBAAkB;IAClD,IAAI,uBAAuB,MAAM;QAC/B;IACF,OAAO,IAAI,uBAAuB,WAAW;QAC3C,OAAO,MAAM,CAAC;YACZ,MAAM,OAAO,CAAA,GAAA,+LAAA,CAAA,WAAQ,AAAD;YACpB,IAAI,KAAK,OAAO,IAAI;gBAClB,MAAM,YAAY,CAAA,GAAA,+LAAA,CAAA,uBAAoB,AAAD;gBACrC,KAAK,MAAM,CAAC;gBACZ,MAAM,gBAAgB,cAAc,SAAS,aAAa,GAAG;gBAC7D,IAAI,CAAA,GAAA,+LAAA,CAAA,gBAAa,AAAD,QAAQ,QAAQ,kBAAkB,QAAQ,kBAAkB,OAAO,cAAc,IAAI;oBACnG,UAAU,MAAM;gBAClB;YACF;QACF,GAAG;IACL,OAAO,IAAI,uBAAuB,MAAM;QACtC,OAAQ,OAAO;YACb,KAAK;gBACH;oBACE,MAAM,oBAAoB,OAAO,gBAAgB,CAAC;oBAClD,OAAO,cAAc,CAAC,mBAAmB;oBACzC;gBACF;YACF,KAAK;gBACH;oBACE,OAAO,cAAc,CAAC,oBAAoB;oBAC1C;gBACF;YACF,KAAK;gBACH;oBACE,OAAO,MAAM,CAAC;wBACZ,MAAM,OAAO,CAAA,GAAA,+LAAA,CAAA,WAAQ,AAAD;wBACpB,IAAI,KAAK,OAAO,IAAI;4BAClB,mBAAmB;wBACrB;oBACF,GAAG;oBACH;gBACF;QACJ;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/useLexicalEditable.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLayoutEffect, useEffect, useMemo, useState, useRef } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n * @param subscription - The function to create the {@link LexicalSubscription}. This function's identity must be stable (e.g. defined at module scope or with useCallback).\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = useLexicalComposerContext();\n  const initializedSubscription = useMemo(() => subscription(editor), [editor, subscription]);\n  const [value, setValue] = useState(() => initializedSubscription.initialValueFn());\n  const valueRef = useRef(value);\n  useLayoutEffectImpl(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\n/**\n * Get the current value for {@link LexicalEditor.isEditable}\n * using {@link useLexicalSubscription}.\n * You should prefer this over manually observing the value with\n * {@link LexicalEditor.registerEditableListener},\n * which is a bit tricky to do correctly, particularly when using\n * React StrictMode (the default for development) or concurrency.\n */\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\nexport { useLexicalEditable };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAED;AACA;;;AAEA;;;;;;CAMC,GAED,MAAM,cAAc,OAAO,WAAW,eAAe,OAAO,OAAO,QAAQ,KAAK,eAAe,OAAO,OAAO,QAAQ,CAAC,aAAa,KAAK;AAExI;;;;;;CAMC,GAGD,sDAAsD;AACtD,wCAAwC;AACxC,+CAA+C;AAC/C,MAAM,sBAAsB,cAAc,yVAAA,CAAA,kBAAe,GAAG,yVAAA,CAAA,YAAS;AAErE;;;;;;CAMC,GAED;;;CAGC,GACD,SAAS,uBAAuB,YAAY;IAC1C,MAAM,CAAC,OAAO,GAAG,CAAA,GAAA,sUAAA,CAAA,4BAAyB,AAAD;IACzC,MAAM,0BAA0B,CAAA,GAAA,yVAAA,CAAA,UAAO,AAAD,EAAE,IAAM,aAAa,SAAS;QAAC;QAAQ;KAAa;IAC1F,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,yVAAA,CAAA,WAAQ,AAAD,EAAE,IAAM,wBAAwB,cAAc;IAC/E,MAAM,WAAW,CAAA,GAAA,yVAAA,CAAA,SAAM,AAAD,EAAE;IACxB,oBAAoB;QAClB,MAAM,EACJ,cAAc,EACd,SAAS,EACV,GAAG;QACJ,MAAM,eAAe;QACrB,IAAI,SAAS,OAAO,KAAK,cAAc;YACrC,SAAS,OAAO,GAAG;YACnB,SAAS;QACX;QACA,OAAO,UAAU,CAAA;YACf,SAAS,OAAO,GAAG;YACnB,SAAS;QACX;IACF,GAAG;QAAC;QAAyB;KAAa;IAC1C,OAAO;AACT;AAEA;;;;;;CAMC,GAED,SAAS,aAAa,MAAM;IAC1B,OAAO;QACL,gBAAgB,IAAM,OAAO,UAAU;QACvC,WAAW,CAAA;YACT,OAAO,OAAO,wBAAwB,CAAC;QACzC;IACF;AACF;AAEA;;;;;;;CAOC,GACD,SAAS;IACP,OAAO,uBAAuB;AAChC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 331, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalRichTextPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable';\nimport { $canShowPlaceholderCurry } from '@lexical/text';\nimport { mergeRegister } from '@lexical/utils';\nimport { useLayoutEffect, useEffect, useState, useMemo, Suspense } from 'react';\nimport { flushSync, createPortal } from 'react-dom';\nimport { jsx, jsxs, Fragment } from 'react/jsx-runtime';\nimport { registerDragonSupport } from '@lexical/dragon';\nimport { registerRichText } from '@lexical/rich-text';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = useState(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffectImpl(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/jsx(ErrorBoundary, {\n        onError: e => editor._onError(e),\n        children: /*#__PURE__*/jsx(Suspense, {\n          fallback: null,\n          children: decorators[nodeKey]\n        })\n      });\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push(/*#__PURE__*/createPortal(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useRichTextSetup(editor) {\n  useLayoutEffectImpl(() => {\n    return mergeRegister(registerRichText(editor), registerDragonSupport(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction RichTextPlugin({\n  contentEditable,\n  // TODO Remove. This property is now part of ContentEditable\n  placeholder = null,\n  ErrorBoundary\n}) {\n  const [editor] = useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/jsxs(Fragment, {\n    children: [contentEditable, /*#__PURE__*/jsx(Placeholder, {\n      content: placeholder\n    }), decorators]\n  });\n}\n\n// TODO remove\nfunction Placeholder({\n  content\n}) {\n  const [editor] = useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexport { RichTextPlugin };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 511, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalContentEditable.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLayoutEffect, useEffect, forwardRef, useState, useCallback, useMemo } from 'react';\nimport { jsx, jsxs, Fragment } from 'react/jsx-runtime';\nimport { $canShowPlaceholderCurry } from '@lexical/text';\nimport { mergeRegister } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// Source: https://github.com/gregberge/react-merge-refs/blob/main/src/index.tsx\n\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ContentEditableElementImpl({\n  editor,\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaErrorMessage,\n  ariaExpanded,\n  ariaInvalid,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}, ref) {\n  const [isEditable, setEditable] = useState(editor.isEditable());\n  const handleRef = useCallback(rootElement => {\n    // defaultView is required for a root element.\n    // In multi-window setups, the defaultView may not exist at certain points.\n    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {\n      editor.setRootElement(rootElement);\n    } else {\n      editor.setRootElement(null);\n    }\n  }, [editor]);\n  const mergedRefs = useMemo(() => mergeRefs(ref, handleRef), [handleRef, ref]);\n  useLayoutEffectImpl(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/jsx(\"div\", {\n    \"aria-activedescendant\": isEditable ? ariaActiveDescendant : undefined,\n    \"aria-autocomplete\": isEditable ? ariaAutoComplete : 'none',\n    \"aria-controls\": isEditable ? ariaControls : undefined,\n    \"aria-describedby\": ariaDescribedBy\n    // for compat, only override aria-errormessage if ariaErrorMessage is defined\n    ,\n    ...(ariaErrorMessage != null ? {\n      'aria-errormessage': ariaErrorMessage\n    } : {}),\n    \"aria-expanded\": isEditable && role === 'combobox' ? !!ariaExpanded : undefined\n    // for compat, only override aria-invalid if ariaInvalid is defined\n    ,\n    ...(ariaInvalid != null ? {\n      'aria-invalid': ariaInvalid\n    } : {}),\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": isEditable ? ariaOwns : undefined,\n    \"aria-readonly\": isEditable ? undefined : true,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: mergedRefs,\n    role: role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex,\n    ...rest\n  });\n}\nconst ContentEditableElement = /*#__PURE__*/forwardRef(ContentEditableElementImpl);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * @deprecated This type has been renamed to `ContentEditableProps` to provide a clearer and more descriptive name.\n * For backward compatibility, this type is still exported as `Props`, but it is recommended to migrate to using `ContentEditableProps` instead.\n *\n * @note This alias is maintained for compatibility purposes but may be removed in future versions.\n * Please update your codebase to use `ContentEditableProps` to ensure long-term maintainability.\n */\n\nconst ContentEditable = /*#__PURE__*/forwardRef(ContentEditableImpl);\nfunction ContentEditableImpl(props, ref) {\n  const {\n    placeholder,\n    ...rest\n  } = props;\n  const [editor] = useLexicalComposerContext();\n  return /*#__PURE__*/jsxs(Fragment, {\n    children: [/*#__PURE__*/jsx(ContentEditableElement, {\n      editor: editor,\n      ...rest,\n      ref: ref\n    }), placeholder != null && /*#__PURE__*/jsx(Placeholder, {\n      editor: editor,\n      content: placeholder\n    })]\n  });\n}\nfunction Placeholder({\n  content,\n  editor\n}) {\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const [isEditable, setEditable] = useState(editor.isEditable());\n  useLayoutEffect(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  if (!showPlaceholder) {\n    return null;\n  }\n  let placeholder = null;\n  if (typeof content === 'function') {\n    placeholder = content(isEditable);\n  } else if (content !== null) {\n    placeholder = content;\n  }\n  if (placeholder === null) {\n    return null;\n  }\n  return /*#__PURE__*/jsx(\"div\", {\n    \"aria-hidden\": true,\n    children: placeholder\n  });\n}\n\nexport { ContentEditable, ContentEditableElement };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 722, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalHistoryPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { createEmptyHistoryState, registerHistory } from '@lexical/history';\nexport { createEmptyHistoryState } from '@lexical/history';\nimport { useMemo, useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = useMemo(() => externalHistoryState || createEmptyHistoryState(), [externalHistoryState]);\n  useEffect(() => {\n    return registerHistory(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HistoryPlugin({\n  delay,\n  externalHistoryState\n}) {\n  const [editor] = useLexicalComposerContext();\n  useHistory(editor, externalHistoryState, delay);\n  return null;\n}\n\nexport { HistoryPlugin };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAED;AACA;AAEA;;;;;AAEA;;;;;;CAMC,GAED,SAAS,WAAW,MAAM,EAAE,oBAAoB,EAAE,QAAQ,IAAI;IAC5D,MAAM,eAAe,CAAA,GAAA,yVAAA,CAAA,UAAO,AAAD,EAAE,IAAM,wBAAwB,CAAA,GAAA,gOAAA,CAAA,0BAAuB,AAAD,KAAK;QAAC;KAAqB;IAC5G,CAAA,GAAA,yVAAA,CAAA,YAAS,AAAD,EAAE;QACR,OAAO,CAAA,GAAA,gOAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ,cAAc;IAC/C,GAAG;QAAC;QAAO;QAAQ;KAAa;AAClC;AAEA;;;;;;CAMC,GAED,SAAS,cAAc,EACrB,KAAK,EACL,oBAAoB,EACrB;IACC,MAAM,CAAC,OAAO,GAAG,CAAA,GAAA,sUAAA,CAAA,4BAAyB,AAAD;IACzC,WAAW,QAAQ,sBAAsB;IACzC,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 774, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalErrorBoundary.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as React from 'react';\nimport { jsx } from 'react/jsx-runtime';\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/React.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/React.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(React.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/jsx(ErrorBoundary, {\n    fallback: /*#__PURE__*/jsx(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      },\n      children: \"An error was thrown.\"\n    }),\n    onError: onError,\n    children: children\n  });\n}\n\nexport { LexicalErrorBoundary };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 910, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalListPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { registerList, ListNode, ListItemNode, registerListStrictIndentTransform } from '@lexical/list';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useList(editor) {\n  useEffect(() => {\n    return registerList(editor);\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ListPlugin({\n  hasStrictIndent = false\n}) {\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    if (!editor.hasNodes([ListNode, ListItemNode])) {\n      throw new Error('ListPlugin: ListNode and/or ListItemNode not registered on editor');\n    }\n  }, [editor]);\n  useEffect(() => {\n    if (!hasStrictIndent) {\n      return;\n    }\n    return registerListStrictIndentTransform(editor);\n  }, [editor, hasStrictIndent]);\n  useList(editor);\n  return null;\n}\n\nexport { ListPlugin };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAED;AACA;AACA;;;;AAEA;;;;;;CAMC,GAED,SAAS,QAAQ,MAAM;IACrB,CAAA,GAAA,yVAAA,CAAA,YAAS,AAAD,EAAE;QACR,OAAO,CAAA,GAAA,uNAAA,CAAA,eAAY,AAAD,EAAE;IACtB,GAAG;QAAC;KAAO;AACb;AAEA;;;;;;CAMC,GAED,SAAS,WAAW,EAClB,kBAAkB,KAAK,EACxB;IACC,MAAM,CAAC,OAAO,GAAG,CAAA,GAAA,sUAAA,CAAA,4BAAyB,AAAD;IACzC,CAAA,GAAA,yVAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,OAAO,QAAQ,CAAC;YAAC,uNAAA,CAAA,WAAQ;YAAE,uNAAA,CAAA,eAAY;SAAC,GAAG;YAC9C,MAAM,IAAI,MAAM;QAClB;IACF,GAAG;QAAC;KAAO;IACX,CAAA,GAAA,yVAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,iBAAiB;YACpB;QACF;QACA,OAAO,CAAA,GAAA,uNAAA,CAAA,oCAAiC,AAAD,EAAE;IAC3C,GAAG;QAAC;QAAQ;KAAgB;IAC5B,QAAQ;IACR,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 975, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/useLexicalNodeSelection.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { $getSelection, $isNodeSelection, $createNodeSelection, $setSelection, $getNodeByKey } from 'lexical';\nimport { useState, useEffect, useCallback } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * A helper function to determine if a specific node is selected in a Lexical editor.\n *\n * @param {LexicalEditor} editor - The LexicalEditor instance.\n * @param {NodeKey} key - The key of the node to check.\n * @returns {boolean} Whether the node is selected.\n */\n\nfunction isNodeSelected(editor, key) {\n  return editor.getEditorState().read(() => {\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      return false; // Node doesn't exist, so it's not selected.\n    }\n    return node.isSelected(); // Check if the node is selected.\n  });\n}\n\n/**\n * A custom hook to manage the selection state of a specific node in a Lexical editor.\n *\n * This hook provides utilities to:\n * - Check if a node is selected.\n * - Update its selection state.\n * - Clear the selection.\n *\n * @param {NodeKey} key - The key of the node to track selection for.\n * @returns {[boolean, (selected: boolean) => void, () => void]} A tuple containing:\n * - `isSelected` (boolean): Whether the node is currently selected.\n * - `setSelected` (function): A function to set the selection state of the node.\n * - `clearSelected` (function): A function to clear the selection of the node.\n *\n */\n\nfunction useLexicalNodeSelection(key) {\n  const [editor] = useLexicalComposerContext();\n\n  // State to track whether the node is currently selected.\n  const [isSelected, setIsSelected] = useState(() => isNodeSelected(editor, key));\n  useEffect(() => {\n    let isMounted = true;\n    const unregister = editor.registerUpdateListener(() => {\n      if (isMounted) {\n        setIsSelected(isNodeSelected(editor, key));\n      }\n    });\n    return () => {\n      isMounted = false; // Prevent updates after component unmount.\n      unregister();\n    };\n  }, [editor, key]);\n  const setSelected = useCallback(selected => {\n    editor.update(() => {\n      let selection = $getSelection();\n      if (!$isNodeSelection(selection)) {\n        selection = $createNodeSelection();\n        $setSelection(selection);\n      }\n      if ($isNodeSelection(selection)) {\n        if (selected) {\n          selection.add(key);\n        } else {\n          selection.delete(key);\n        }\n      }\n    });\n  }, [editor, key]);\n  const clearSelected = useCallback(() => {\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isNodeSelection(selection)) {\n        selection.clear();\n      }\n    });\n  }, [editor]);\n  return [isSelected, setSelected, clearSelected];\n}\n\nexport { useLexicalNodeSelection };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAED;AACA;AACA;;;;AAEA;;;;;;CAMC,GAGD;;;;;;CAMC,GAED,SAAS,eAAe,MAAM,EAAE,GAAG;IACjC,OAAO,OAAO,cAAc,GAAG,IAAI,CAAC;QAClC,MAAM,OAAO,CAAA,GAAA,+LAAA,CAAA,gBAAa,AAAD,EAAE;QAC3B,IAAI,SAAS,MAAM;YACjB,OAAO,OAAO,4CAA4C;QAC5D;QACA,OAAO,KAAK,UAAU,IAAI,iCAAiC;IAC7D;AACF;AAEA;;;;;;;;;;;;;;CAcC,GAED,SAAS,wBAAwB,GAAG;IAClC,MAAM,CAAC,OAAO,GAAG,CAAA,GAAA,sUAAA,CAAA,4BAAyB,AAAD;IAEzC,yDAAyD;IACzD,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,yVAAA,CAAA,WAAQ,AAAD,EAAE,IAAM,eAAe,QAAQ;IAC1E,CAAA,GAAA,yVAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,YAAY;QAChB,MAAM,aAAa,OAAO,sBAAsB,CAAC;YAC/C,IAAI,WAAW;gBACb,cAAc,eAAe,QAAQ;YACvC;QACF;QACA,OAAO;YACL,YAAY,OAAO,2CAA2C;YAC9D;QACF;IACF,GAAG;QAAC;QAAQ;KAAI;IAChB,MAAM,cAAc,CAAA,GAAA,yVAAA,CAAA,cAAW,AAAD,EAAE,CAAA;QAC9B,OAAO,MAAM,CAAC;YACZ,IAAI,YAAY,CAAA,GAAA,+LAAA,CAAA,gBAAa,AAAD;YAC5B,IAAI,CAAC,CAAA,GAAA,+LAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY;gBAChC,YAAY,CAAA,GAAA,+LAAA,CAAA,uBAAoB,AAAD;gBAC/B,CAAA,GAAA,+LAAA,CAAA,gBAAa,AAAD,EAAE;YAChB;YACA,IAAI,CAAA,GAAA,+LAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY;gBAC/B,IAAI,UAAU;oBACZ,UAAU,GAAG,CAAC;gBAChB,OAAO;oBACL,UAAU,MAAM,CAAC;gBACnB;YACF;QACF;IACF,GAAG;QAAC;QAAQ;KAAI;IAChB,MAAM,gBAAgB,CAAA,GAAA,yVAAA,CAAA,cAAW,AAAD,EAAE;QAChC,OAAO,MAAM,CAAC;YACZ,MAAM,YAAY,CAAA,GAAA,+LAAA,CAAA,gBAAa,AAAD;YAC9B,IAAI,CAAA,GAAA,+LAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY;gBAC/B,UAAU,KAAK;YACjB;QACF;IACF,GAAG;QAAC;KAAO;IACX,OAAO;QAAC;QAAY;QAAa;KAAc;AACjD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1086, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Breact%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalTreeView.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalCommandsLog, TreeView as TreeView$1, generateContent } from '@lexical/devtools-core';\nimport { mergeRegister } from '@lexical/utils';\nimport * as React from 'react';\nimport { useState, useEffect } from 'react';\nimport { jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction TreeView({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  timeTravelPanelClassName,\n  viewClassName,\n  editor,\n  customPrintNode\n}) {\n  const treeElementRef = /*#__PURE__*/React.createRef();\n  const [editorCurrentState, setEditorCurrentState] = useState(editor.getEditorState());\n  const commandsLog = useLexicalCommandsLog(editor);\n  useEffect(() => {\n    // Registers listeners to update the tree view when the editor state changes\n    return mergeRegister(editor.registerUpdateListener(({\n      editorState\n    }) => {\n      setEditorCurrentState(editorState);\n    }), editor.registerEditableListener(() => {\n      setEditorCurrentState(editor.getEditorState());\n    }));\n  }, [editor]);\n  useEffect(() => {\n    const element = treeElementRef.current;\n    if (element !== null) {\n      // Assigns the editor instance to the tree view DOM element for internal tracking\n      // @ts-ignore Internal field used by Lexical\n      element.__lexicalEditor = editor;\n      return () => {\n        // Cleans up the reference when the component is unmounted\n        // @ts-ignore Internal field used by Lexical\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor, treeElementRef]);\n\n  /**\n   * Handles toggling the readonly state of the editor.\n   *\n   * @param {boolean} isReadonly - Whether the editor should be set to readonly.\n   */\n  const handleEditorReadOnly = isReadonly => {\n    const rootElement = editor.getRootElement();\n    if (rootElement == null) {\n      return;\n    }\n    rootElement.contentEditable = isReadonly ? 'false' : 'true';\n  };\n  return /*#__PURE__*/jsx(TreeView$1, {\n    treeTypeButtonClassName: treeTypeButtonClassName,\n    timeTravelButtonClassName: timeTravelButtonClassName,\n    timeTravelPanelSliderClassName: timeTravelPanelSliderClassName,\n    timeTravelPanelButtonClassName: timeTravelPanelButtonClassName,\n    viewClassName: viewClassName,\n    timeTravelPanelClassName: timeTravelPanelClassName,\n    setEditorReadOnly: handleEditorReadOnly,\n    editorState: editorCurrentState,\n    setEditorState: state => editor.setEditorState(state),\n    generateContent: async function (exportDOM) {\n      // Generates the content for the tree view, allowing customization with exportDOM and customPrintNode\n      return generateContent(editor, commandsLog, exportDOM, customPrintNode);\n    },\n    ref: treeElementRef,\n    commandsLog: commandsLog\n  });\n}\n\nexport { TreeView };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAED;AACA;AACA;AAEA;;;;;;AAEA;;;;;;CAMC,GAED,SAAS,SAAS,EAChB,uBAAuB,EACvB,yBAAyB,EACzB,8BAA8B,EAC9B,8BAA8B,EAC9B,wBAAwB,EACxB,aAAa,EACb,MAAM,EACN,eAAe,EAChB;IACC,MAAM,iBAAiB,WAAW,GAAE,CAAA,GAAA,yVAAA,CAAA,YAAe,AAAD;IAClD,MAAM,CAAC,oBAAoB,sBAAsB,GAAG,CAAA,GAAA,yVAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,cAAc;IAClF,MAAM,cAAc,CAAA,GAAA,oUAAA,CAAA,wBAAqB,AAAD,EAAE;IAC1C,CAAA,GAAA,yVAAA,CAAA,YAAS,AAAD,EAAE;QACR,4EAA4E;QAC5E,OAAO,CAAA,GAAA,0OAAA,CAAA,gBAAa,AAAD,EAAE,OAAO,sBAAsB,CAAC,CAAC,EAClD,WAAW,EACZ;YACC,sBAAsB;QACxB,IAAI,OAAO,wBAAwB,CAAC;YAClC,sBAAsB,OAAO,cAAc;QAC7C;IACF,GAAG;QAAC;KAAO;IACX,CAAA,GAAA,yVAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,UAAU,eAAe,OAAO;QACtC,IAAI,YAAY,MAAM;YACpB,iFAAiF;YACjF,4CAA4C;YAC5C,QAAQ,eAAe,GAAG;YAC1B,OAAO;gBACL,0DAA0D;gBAC1D,4CAA4C;gBAC5C,QAAQ,eAAe,GAAG;YAC5B;QACF;IACF,GAAG;QAAC;QAAQ;KAAe;IAE3B;;;;GAIC,GACD,MAAM,uBAAuB,CAAA;QAC3B,MAAM,cAAc,OAAO,cAAc;QACzC,IAAI,eAAe,MAAM;YACvB;QACF;QACA,YAAY,eAAe,GAAG,aAAa,UAAU;IACvD;IACA,OAAO,WAAW,GAAE,CAAA,GAAA,2WAAA,CAAA,MAAG,AAAD,EAAE,oUAAA,CAAA,WAAU,EAAE;QAClC,yBAAyB;QACzB,2BAA2B;QAC3B,gCAAgC;QAChC,gCAAgC;QAChC,eAAe;QACf,0BAA0B;QAC1B,mBAAmB;QACnB,aAAa;QACb,gBAAgB,CAAA,QAAS,OAAO,cAAc,CAAC;QAC/C,iBAAiB,eAAgB,SAAS;YACxC,qGAAqG;YACrG,OAAO,CAAA,GAAA,oUAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ,aAAa,WAAW;QACzD;QACA,KAAK;QACL,aAAa;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1176, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Btext%400.33.1/node_modules/%40lexical/text/LexicalText.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isParagraphNode, $isTextNode, TextNode, $createTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        formatDevErrorMessage(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;;AAED;;AAEA;;;;;;CAMC,GAED;;;CAGC,GACD,SAAS;IACP,MAAM,OAAO,CAAA,GAAA,+LAAA,CAAA,WAAQ,AAAD;IACpB,OAAO,KAAK,cAAc;AAC5B;AAEA;;;;;;CAMC,GAED;;;;;CAKC,GACD,SAAS,wBAAwB,iBAAiB,EAAE,OAAO,IAAI;IAC7D,IAAI,mBAAmB;QACrB,OAAO;IACT;IACA,IAAI,OAAO;IACX,IAAI,MAAM;QACR,OAAO,KAAK,IAAI;IAClB;IACA,OAAO,SAAS;AAClB;AAEA;;;;;CAKC,GACD,SAAS,6BAA6B,iBAAiB,EAAE,IAAI;IAC3D,OAAO,IAAM,wBAAwB,mBAAmB;AAC1D;AAEA;;;;;;CAMC,GAED;;;;;CAKC,GACD,SAAS,oBAAoB,WAAW;IACtC,IAAI,CAAC,wBAAwB,aAAa,QAAQ;QAChD,OAAO;IACT;IACA,MAAM,OAAO,CAAA,GAAA,+LAAA,CAAA,WAAQ,AAAD;IACpB,MAAM,WAAW,KAAK,WAAW;IACjC,MAAM,iBAAiB,SAAS,MAAM;IACtC,IAAI,iBAAiB,GAAG;QACtB,OAAO;IACT;IACA,IAAK,IAAI,IAAI,GAAG,IAAI,gBAAgB,IAAK;QACvC,MAAM,WAAW,QAAQ,CAAC,EAAE;QAC5B,IAAI,CAAA,GAAA,+LAAA,CAAA,mBAAgB,AAAD,EAAE,WAAW;YAC9B,OAAO;QACT;QACA,IAAI,CAAA,GAAA,+LAAA,CAAA,iBAAc,AAAD,EAAE,WAAW;YAC5B,IAAI,CAAC,CAAA,GAAA,+LAAA,CAAA,mBAAgB,AAAD,EAAE,WAAW;gBAC/B,OAAO;YACT;YACA,IAAI,SAAS,QAAQ,KAAK,GAAG;gBAC3B,OAAO;YACT;YACA,MAAM,mBAAmB,SAAS,WAAW;YAC7C,MAAM,yBAAyB,iBAAiB,MAAM;YACtD,IAAK,IAAI,IAAI,GAAG,IAAI,wBAAwB,IAAK;gBAC/C,MAAM,QAAQ,gBAAgB,CAAC,EAAE;gBACjC,IAAI,CAAC,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,QAAQ;oBACvB,OAAO;gBACT;YACF;QACF;IACF;IACA,OAAO;AACT;AAEA;;;;CAIC,GACD,SAAS,yBAAyB,iBAAiB;IACjD,OAAO,IAAM,oBAAoB;AACnC;AAEA;;;;;;CAMC,GAED;;;;;;CAMC,GACD,SAAS,oCAAoC,IAAI,EAAE,gBAAgB;IACjE,IAAI,OAAO,KAAK,aAAa;IAC7B,IAAI,oBAAoB;IACxB,UAAU,MAAO,SAAS,KAAM;QAC9B,IAAI,CAAA,GAAA,+LAAA,CAAA,iBAAc,AAAD,EAAE,OAAO;YACxB,MAAM,QAAQ,KAAK,aAAa;YAChC,IAAI,UAAU,MAAM;gBAClB,OAAO;gBACP;YACF;QACF,OAAO,IAAI,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,OAAO;YAC5B,MAAM,aAAa,KAAK,kBAAkB;YAC1C,IAAI,oBAAoB,aAAa,kBAAkB;gBACrD,OAAO;oBACL;oBACA,QAAQ,mBAAmB;gBAC7B;YACF;YACA,qBAAqB;QACvB;QACA,MAAM,UAAU,KAAK,cAAc;QACnC,IAAI,YAAY,MAAM;YACpB,OAAO;YACP;QACF;QACA,IAAI,SAAS,KAAK,SAAS;QAC3B,MAAO,WAAW,KAAM;YACtB,MAAM,gBAAgB,OAAO,cAAc;YAC3C,IAAI,kBAAkB,MAAM;gBAC1B,OAAO;gBACP,SAAS;YACX;YACA,SAAS,OAAO,SAAS;QAC3B;QACA;IACF;IACA,OAAO;AACT;AAEA;;;;;;CAMC,GAED,qEAAqE;AAErE,SAAS,sBAAsB,OAAO;IACpC,MAAM,IAAI,MAAM;AAClB;AAEA;;;;;;;;;;;;;;;;;;CAkBC,GACD,SAAS,0BAA0B,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,UAAU;IACzE,MAAM,eAAe,CAAA;QACnB,OAAO,gBAAgB;IACzB;IACA,MAAM,yBAAyB,CAAA;QAC7B,MAAM,WAAW,CAAA,GAAA,+LAAA,CAAA,kBAAe,AAAD,EAAE,KAAK,cAAc;QACpD,SAAS,SAAS,CAAC,KAAK,SAAS;QACjC,KAAK,OAAO,CAAC;IACf;IACA,MAAM,UAAU,CAAA;QACd,OAAO,KAAK,SAAS,GAAG,MAAM;IAChC;IACA,MAAM,qBAAqB,CAAA;QACzB,IAAI,CAAC,KAAK,YAAY,IAAI;YACxB;QACF;QACA,IAAI,cAAc,KAAK,kBAAkB;QACzC,IAAI,OAAO,KAAK,cAAc;QAC9B,IAAI,cAAc;QAClB,IAAI;QACJ,IAAI,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,cAAc;YAC5B,MAAM,eAAe,YAAY,cAAc;YAC/C,MAAM,eAAe,eAAe;YACpC,MAAM,YAAY,SAAS;YAC3B,IAAI,aAAa,cAAc;gBAC7B,IAAI,cAAc,QAAQ,QAAQ,iBAAiB,GAAG;oBACpD,uBAAuB;oBACvB;gBACF,OAAO;oBACL,MAAM,OAAO,UAAU,GAAG,GAAG,aAAa,MAAM;oBAChD,IAAI,OAAO,GAAG;wBACZ,MAAM,aAAa,KAAK,KAAK,CAAC,GAAG;wBACjC,MAAM,iBAAiB,eAAe;wBACtC,YAAY,MAAM;wBAClB,YAAY,cAAc,CAAC;wBAC3B,IAAI,SAAS,KAAK,MAAM,EAAE;4BACxB,KAAK,MAAM;wBACb,OAAO;4BACL,MAAM,gBAAgB,KAAK,KAAK,CAAC;4BACjC,KAAK,cAAc,CAAC;wBACtB;wBACA;oBACF;gBACF;YACF,OAAO,IAAI,cAAc,QAAQ,UAAU,KAAK,GAAG,aAAa,MAAM,EAAE;gBACtE;YACF;QACF;QACA,IAAI,wBAAwB;QAC5B,iDAAiD;QACjD,MAAO,KAAM;YACX,QAAQ,SAAS;YACjB,IAAI,WAAW,UAAU,OAAO,KAAK,KAAK,KAAK,CAAC,MAAM,GAAG;YACzD,OAAO;YACP,IAAI,aAAa,IAAI;gBACnB,MAAM,cAAc,YAAY,cAAc;gBAC9C,IAAI,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,cAAc;oBAC5B,WAAW,YAAY,cAAc,KAAK,YAAY,cAAc;oBACpE,MAAM,YAAY,SAAS;oBAC3B,IAAI,cAAc,MAAM;wBACtB,IAAI,aAAa,cAAc;4BAC7B,uBAAuB;wBACzB,OAAO;4BACL,YAAY,SAAS;wBACvB;wBACA;oBACF,OAAO,IAAI,UAAU,KAAK,KAAK,GAAG;wBAChC;oBACF;gBACF;YACF;YACA,IAAI,UAAU,MAAM;gBAClB;YACF;YACA,IAAI,MAAM,KAAK,KAAK,KAAK,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,gBAAgB,YAAY,YAAY,IAAI;gBAC/E,yBAAyB,MAAM,GAAG;gBAClC;YACF;YACA,IAAI;YACJ,IAAI,MAAM,KAAK,KAAK,GAAG;gBACrB,CAAC,eAAe,YAAY,GAAG,YAAY,SAAS,CAAC,MAAM,GAAG;YAChE,OAAO;gBACL,GAAG,eAAe,YAAY,GAAG,YAAY,SAAS,CAAC,MAAM,KAAK,GAAG,uBAAuB,MAAM,GAAG,GAAG;YAC1G;YACA,IAAI,CAAC,CAAC,kBAAkB,SAAS,GAAG;gBAClC,sBAAsB,GAAG,gBAAgB,qFAAqF,CAAC;YACjI;YACA,MAAM,kBAAkB,WAAW;YACnC,gBAAgB,SAAS,CAAC,cAAc,SAAS;YACjD,cAAc,OAAO,CAAC;YACtB,IAAI,eAAe,MAAM;gBACvB;YACF;YACA,wBAAwB;YACxB,cAAc;QAChB;IACF;IACA,MAAM,wBAAwB,CAAA;QAC5B,MAAM,OAAO,KAAK,cAAc;QAChC,MAAM,QAAQ,SAAS;QACvB,IAAI,UAAU,QAAQ,MAAM,KAAK,KAAK,GAAG;YACvC,uBAAuB;YACvB;QACF;QACA,IAAI,KAAK,MAAM,GAAG,MAAM,GAAG,EAAE;YAC3B,0DAA0D;YAC1D,KAAK,SAAS,CAAC,MAAM,GAAG;YACxB;QACF;QACA,MAAM,cAAc,KAAK,kBAAkB;QAC3C,IAAI,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,gBAAgB,YAAY,YAAY,IAAI;YAC1D,uBAAuB;YACvB,uBAAuB;QACzB;QACA,MAAM,cAAc,KAAK,cAAc;QACvC,IAAI,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,gBAAgB,YAAY,YAAY,IAAI;YAC1D,uBAAuB;YAEvB,6DAA6D;YAC7D,IAAI,aAAa,OAAO;gBACtB,uBAAuB;YACzB;QACF;IACF;IACA,MAAM,2BAA2B,OAAO,qBAAqB,CAAC,+LAAA,CAAA,WAAQ,EAAE;IACxE,MAAM,6BAA6B,OAAO,qBAAqB,CAAC,YAAY;IAC5E,OAAO;QAAC;QAA0B;KAA2B;AAC/D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1502, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Bselection%400.33.1/node_modules/%40lexical/selection/LexicalSelection.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isTextNode, $isTokenOrSegmented, $getCharacterOffsets, $isElementNode, $isRootNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $getSelection, $caretRangeFromSelection, $createRangeSelection, INTERNAL_$isBlock, $setSelection, $isRootOrShadowRoot, $hasAncestor, $isLeafNode, $caretFromPoint, $isExtendableTextPointCaret, $extendCaretToRange, $isChildCaret, $isDecoratorNode, $getEditor } from 'lexical';\nexport { $cloneWithProperties, $selectAll } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !$isTokenOrSegmented(textNode) && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      // NOTE: This mutates __text directly because the primary use case is to\n      // modify a $cloneWithProperties node that should never be added\n      // to the EditorState so we must not call getWritable via setTextContent\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\n/**\n * Applies the provided styles to the given TextNode, ElementNode, or\n * collapsed RangeSelection.\n *\n * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyle(target, patch) {\n  if (!($isRangeSelection(target) ? target.isCollapsed() : $isTextNode(target) || $isElementNode(target))) {\n    formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);\n  }\n  const prevStyles = getStyleObjectFromCSS($isRangeSelection(target) ? target.style : $isTextNode(target) ? target.getStyle() : target.getTextStyle());\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  });\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  if ($isRangeSelection(target) || $isTextNode(target)) {\n    target.setStyle(newCSSText);\n  } else {\n    target.setTextStyle(newCSSText);\n  }\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    const emptyNode = selection.anchor.getNode();\n    if ($isElementNode(emptyNode) && emptyNode.isEmpty()) {\n      $patchStyle(emptyNode, patch);\n    }\n  }\n  $forEachSelectedTextNode(textNode => {\n    $patchStyle(textNode, patch);\n  });\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = $getSelection();\n  if (!selection) {\n    return;\n  }\n  const slicedTextNodes = new Map();\n  const getSliceIndices = node => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];\n  if ($isRangeSelection(selection)) {\n    for (const slice of $caretRangeFromSelection(selection).getTextSlices()) {\n      if (slice) {\n        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());\n      }\n    }\n  }\n  const selectedNodes = selection.getNodes();\n  for (const selectedNode of selectedNodes) {\n    if (!($isTextNode(selectedNode) && selectedNode.canHaveFormat())) {\n      continue;\n    }\n    const [startOffset, endOffset] = getSliceIndices(selectedNode);\n    // No actual text is selected, so do nothing.\n    if (endOffset === startOffset) {\n      continue;\n    }\n\n    // The entire node is selected or a token/segment, so just format it\n    if ($isTokenOrSegmented(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {\n      fn(selectedNode);\n    } else {\n      // The node is partially selected, so split it into two or three nodes\n      // and style the selected one.\n      const splitNodes = selectedNode.splitText(startOffset, endOffset);\n      const replacement = splitNodes[startOffset === 0 ? 0 : 1];\n      fn(replacement);\n    }\n  }\n  // Prior to NodeCaret #7046 this would have been a side-effect\n  // so we do this for test compatibility.\n  // TODO: we may want to consider simplifying by removing this\n  if ($isRangeSelection(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {\n    $ensureForwardRangeSelection(selection);\n  }\n}\n\n/**\n * Ensure that the given RangeSelection is not backwards. If it\n * is backwards, then the anchor and focus points will be swapped\n * in-place. Ensuring that the selection is a writable RangeSelection\n * is the responsibility of the caller (e.g. in a read-only context\n * you will want to clone $getSelection() before using this).\n *\n * @param selection a writable RangeSelection\n */\nfunction $ensureForwardRangeSelection(selection) {\n  if (selection.isBackward()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    // stash for the in-place swap\n    const {\n      key,\n      offset,\n      type\n    } = anchor;\n    anchor.set(focus.key, focus.offset, focus.type);\n    focus.set(key, offset, type);\n  }\n}\n\nfunction $copyBlockFormatIndent(srcNode, destNode) {\n  const format = srcNode.getFormatType();\n  const indent = srcNode.getIndent();\n  if (format !== destNode.getFormatType()) {\n    destNode.setFormat(format);\n  }\n  if (indent !== destNode.getIndent()) {\n    destNode.setIndent(indent);\n  }\n}\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param $createElement - The function that creates the node. eg. $createParagraphNode.\n * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)\n */\nfunction $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {\n  if (selection === null) {\n    return;\n  }\n  // Selections tend to not include their containing blocks so we effectively\n  // expand it here\n  const anchorAndFocus = selection.getStartEndPoints();\n  const blockMap = new Map();\n  let newSelection = null;\n  if (anchorAndFocus) {\n    const [anchor, focus] = anchorAndFocus;\n    newSelection = $createRangeSelection();\n    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);\n    newSelection.focus.set(focus.key, focus.offset, focus.type);\n    const anchorBlock = $getAncestor(anchor.getNode(), INTERNAL_$isBlock);\n    const focusBlock = $getAncestor(focus.getNode(), INTERNAL_$isBlock);\n    if ($isElementNode(anchorBlock)) {\n      blockMap.set(anchorBlock.getKey(), anchorBlock);\n    }\n    if ($isElementNode(focusBlock)) {\n      blockMap.set(focusBlock.getKey(), focusBlock);\n    }\n  }\n  for (const node of selection.getNodes()) {\n    if ($isElementNode(node) && INTERNAL_$isBlock(node)) {\n      blockMap.set(node.getKey(), node);\n    } else if (anchorAndFocus === null) {\n      const ancestorBlock = $getAncestor(node, INTERNAL_$isBlock);\n      if ($isElementNode(ancestorBlock)) {\n        blockMap.set(ancestorBlock.getKey(), ancestorBlock);\n      }\n    }\n  }\n  for (const [key, prevNode] of blockMap) {\n    const element = $createElement();\n    $afterCreateElement(prevNode, element);\n    prevNode.replace(element, true);\n    if (newSelection) {\n      if (key === newSelection.anchor.key) {\n        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);\n      }\n      if (key === newSelection.focus.key) {\n        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);\n      }\n    }\n  }\n  if (newSelection && selection.is($getSelection())) {\n    $setSelection(newSelection);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated In favor of $setBlockTypes\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Tests if the selection's parent element has vertical writing mode.\n * @param selection - The selection whose parent to test.\n * @returns true if the selection's parent has vertical writing mode (writing-mode: vertical-rl), false otherwise.\n */\nfunction $isEditorVerticalOrientation(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  const editor = $getEditor();\n  const domElement = editor.getElementByKey(parent.getKey());\n  if (domElement === null) {\n    return false;\n  }\n  const view = domElement.ownerDocument.defaultView;\n  if (view === null) {\n    return false;\n  }\n  const computedStyle = view.getComputedStyle(domElement);\n  return computedStyle.writingMode === 'vertical-rl';\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical writing mode, we adjust the direction for correct caret movement\n  const adjustedIsBackward = isVertical ? !isBackward : isBackward;\n  const focusCaret = $caretFromPoint(selection.focus, adjustedIsBackward ? 'previous' : 'next');\n  if ($isExtendableTextPointCaret(focusCaret)) {\n    return false;\n  }\n  for (const nextCaret of $extendCaretToRange(focusCaret)) {\n    if ($isChildCaret(nextCaret)) {\n      return !nextCaret.origin.isInline();\n    } else if ($isElementNode(nextCaret.origin)) {\n      continue;\n    } else if ($isDecoratorNode(nextCaret.origin)) {\n      return true;\n    }\n    break;\n  }\n  return false;\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical-rl writing mode, arrow key directions need to be flipped\n  // to match the visual flow of text (top to bottom, right to left)\n  let adjustedIsBackward;\n  if (isVertical) {\n    // In vertical-rl mode, we need to completely invert the direction\n    // Left arrow (backward) should move down (forward)\n    // Right arrow (forward) should move up (backward)\n    adjustedIsBackward = !isBackward;\n  } else if (isRTL) {\n    // In horizontal RTL mode, use the standard RTL behavior\n    adjustedIsBackward = !isBackward;\n  } else {\n    // Standard LTR horizontal text\n    adjustedIsBackward = isBackward;\n  }\n\n  // Apply the direction adjustment to move the caret\n  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ($isRangeSelection(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\nexport { $addNodeStyle, $copyBlockFormatIndent, $ensureForwardRangeSelection, $forEachSelectedTextNode, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $trimTextContentFromAnchor, $wrapNodes, createDOMRange, createRectsFromDOMRange, getCSSFromStyleObject, getStyleObjectFromCSS, trimTextContentFromAnchor };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2443, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Butils%400.33.1/node_modules/%40lexical/utils/LexicalUtils.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, $getSelection, $isRangeSelection, $isElementNode, getDOMTextNode, $getRoot, $getChildCaret, $getSiblingCaret, $getAdjacentChildCaret, $getChildCaretOrSelf, makeStepwiseIterator, $isChildCaret, $cloneWithProperties, $setSelection, $getPreviousSelection, $caretFromPoint, $createParagraphNode, $normalizeCaret, $setSelectionFromCaretRange, $getCollapsedCaretRange, $getCaretInDirection, $splitAtPointCaretNext, $isTextPointCaret, $isSiblingCaret, $rewindSiblingCaret, $getState, $setState } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\nimport { createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't necessarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!isHTMLElement(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !$isElementNode(node)) {\n    const textDOM = getDOMTextNode(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\n\n/**\n * Get the adjacent caret in the same direction\n *\n * @param caret A caret or null\n * @returns `caret.getAdjacentCaret()` or `null`\n */\nfunction $getAdjacentCaret(caret) {\n  return caret ? caret.getAdjacentCaret() : null;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfs(startNode, endNode) {\n  return Array.from($reverseDfsIterator(startNode, endNode));\n}\n\n/**\n * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('next', startNode, endNode);\n}\nfunction $getEndCaret(startNode, direction) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret($getSiblingCaret(startNode, direction));\n  return rval && rval[0];\n}\nfunction $dfsCaretIterator(direction, startNode, endNode) {\n  const root = $getRoot();\n  const start = startNode || root;\n  const startCaret = $isElementNode(start) ? $getChildCaret(start, direction) : $getSiblingCaret(start, direction);\n  const startDepth = $getDepth(start);\n  const endCaret = endNode ? $getAdjacentChildCaret($getChildCaretOrSelf($getSiblingCaret(endNode, direction))) : $getEndCaret(start, direction);\n  let depth = startDepth;\n  return makeStepwiseIterator({\n    hasNext: state => state !== null,\n    initial: startCaret,\n    map: state => ({\n      depth,\n      node: state.origin\n    }),\n    step: state => {\n      if (state.isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      if ($isChildCaret(state)) {\n        depth++;\n      }\n      const rval = $getAdjacentSiblingOrParentSiblingCaret(state);\n      if (!rval || rval[0].isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      depth += rval[1];\n      return rval[0];\n    }\n  });\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret($getSiblingCaret(node, 'next'));\n  return rval && [rval[0].origin, rval[1]];\n}\nfunction $getDepth(node) {\n  let depth = -1;\n  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  const startCaret = $getChildCaretOrSelf($getSiblingCaret(startingNode, 'previous'));\n  const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');\n  return next && next[0].origin;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('previous', startNode, endNode);\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  let initialCaret;\n  if ($isRangeSelection(selection)) {\n    initialCaret = $caretFromPoint(selection.focus, 'next');\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      const lastNode = nodes[nodes.length - 1];\n      if (lastNode) {\n        initialCaret = $getSiblingCaret(lastNode, 'next');\n      }\n    }\n    initialCaret = initialCaret || $getChildCaret($getRoot(), 'previous').getFlipped().insert($createParagraphNode());\n  }\n  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);\n  const adjacent = $getAdjacentChildCaret(insertCaret);\n  const selectionCaret = $isChildCaret(adjacent) ? $normalizeCaret(adjacent) : insertCaret;\n  $setSelectionFromCaretRange($getCollapsedCaretRange(selectionCaret));\n  return node.getLatest();\n}\n\n/**\n * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be inserted there, otherwise the parent nodes will be split according to the\n * given options.\n * @param node - The node to be inserted\n * @param caret - The location to insert or split from\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRootAtCaret(node, caret, options) {\n  let insertCaret = $getCaretInDirection(caret, 'next');\n  for (let nextCaret = insertCaret; nextCaret; nextCaret = $splitAtPointCaretNext(nextCaret, options)) {\n    insertCaret = nextCaret;\n  }\n  if (!!$isTextPointCaret(insertCaret)) {\n    formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);\n  }\n  insertCaret.insert(node.isInline() ? $createParagraphNode().append(node) : node);\n  return $getCaretInDirection($getSiblingCaret(node.getLatest(), 'next'), caret.direction);\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframes)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  $getChildCaret(parent, 'next').insert(node);\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ($isElementNode(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || (child => node.insertAfter(child)));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = Array.from(children).reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ($isElementNode(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return $childIterator($getChildCaret(node, 'next'));\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return $childIterator($getChildCaret(node, 'previous'));\n}\nfunction $childIterator(startCaret) {\n  const seen = new Set() ;\n  return makeStepwiseIterator({\n    hasNext: $isSiblingCaret,\n    initial: startCaret.getAdjacentCaret(),\n    map: caret => {\n      const origin = caret.origin.getLatest();\n      if (seen !== null) {\n        const key = origin.getKey();\n        if (!!seen.has(key)) {\n          formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      return origin;\n    },\n    step: caret => caret.getAdjacentCaret()\n  });\n}\n\n/**\n * Replace this node with its children\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  $rewindSiblingCaret($getSiblingCaret(node, 'next')).splice(1, node.getChildren());\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = $getAdjacentChildCaret(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = $getAdjacentChildCaret(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * A wrapper that creates bound functions and methods for the\n * StateConfig to save some boilerplate when defining methods\n * or exporting only the accessors from your modules rather\n * than exposing the StateConfig directly.\n */\n\n/**\n * EXPERIMENTAL\n *\n * A convenience interface for working with {@link $getState} and\n * {@link $setState}.\n *\n * @param stateConfig The stateConfig to wrap with convenience functionality\n * @returns a StateWrapper\n */\nfunction makeStateWrapper(stateConfig) {\n  const $get = node => $getState(node, stateConfig);\n  const $set = (node, valueOrUpdater) => $setState(node, stateConfig, valueOrUpdater);\n  return {\n    $get,\n    $set,\n    accessors: [$get, $set],\n    makeGetterMethod: () => function $getter() {\n      return $get(this);\n    },\n    makeSetterMethod: () => function $setter(valueOrUpdater) {\n      return $set(this, valueOrUpdater);\n    },\n    stateConfig\n  };\n}\n\nexport { $descendantsMatching, $dfs, $dfsIterator, $filter, $findMatchingParent, $firstToLastIterator, $getAdjacentCaret, $getAdjacentSiblingOrParentSiblingCaret, $getDepth, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $getNextSiblingOrParentSibling, $insertFirst, $insertNodeToNearestRoot, $insertNodeToNearestRootAtCaret, $isEditorIsNestedEditor, $lastToFirstIterator, $restoreEditorState, $reverseDfs, $reverseDfsIterator, $unwrapAndFilterDescendants, $unwrapNode, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, makeStateWrapper, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, mlcPositionNodeOnRange as positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement, selectionAlwaysOnDisplay };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3501, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Bdragon%400.33.1/node_modules/%40lexical/dragon/LexicalDragon.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, $isTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ($isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ($isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexport { registerDragonSupport };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAED;;AAEA;;;;;;CAMC,GAED,SAAS,sBAAsB,MAAM;IACnC,MAAM,SAAS,OAAO,QAAQ,CAAC,MAAM;IACrC,MAAM,UAAU,CAAA;QACd,IAAI,MAAM,MAAM,KAAK,QAAQ;YAC3B;QACF;QACA,MAAM,cAAc,OAAO,cAAc;QACzC,IAAI,SAAS,aAAa,KAAK,aAAa;YAC1C;QACF;QACA,MAAM,OAAO,MAAM,IAAI;QACvB,IAAI,OAAO,SAAS,UAAU;YAC5B,IAAI;YACJ,IAAI;gBACF,aAAa,KAAK,KAAK,CAAC;YAC1B,EAAE,OAAO,GAAG;gBACV;YACF;YACA,IAAI,cAAc,WAAW,QAAQ,KAAK,uBAAuB,WAAW,IAAI,KAAK,WAAW;gBAC9F,MAAM,UAAU,WAAW,OAAO;gBAClC,IAAI,WAAW,QAAQ,UAAU,KAAK,eAAe;oBACnD,MAAM,OAAO,QAAQ,IAAI;oBACzB,IAAI,MAAM;wBACR,MAAM,CAAC,cAAc,eAAe,MAAM,UAAU,WAAW,cAAc,GAAG;wBAChF,OAAO,MAAM,CAAC;4BACZ,MAAM,YAAY,CAAA,GAAA,+LAAA,CAAA,gBAAa,AAAD;4BAC9B,IAAI,CAAA,GAAA,+LAAA,CAAA,oBAAiB,AAAD,EAAE,YAAY;gCAChC,MAAM,SAAS,UAAU,MAAM;gCAC/B,IAAI,aAAa,OAAO,OAAO;gCAC/B,IAAI,cAAc;gCAClB,IAAI,YAAY;gCAChB,IAAI,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,aAAa;oCAC3B,wBAAwB;oCACxB,IAAI,gBAAgB,KAAK,iBAAiB,GAAG;wCAC3C,cAAc;wCACd,YAAY,eAAe;wCAC3B,sDAAsD;wCACtD,UAAU,gBAAgB,CAAC,YAAY,aAAa,YAAY;oCAClE;gCACF;gCACA,IAAI,gBAAgB,aAAa,SAAS,IAAI;oCAC5C,UAAU,aAAa,CAAC;oCACxB,aAAa,OAAO,OAAO;gCAC7B;gCACA,IAAI,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,aAAa;oCAC3B,sBAAsB;oCACtB,cAAc;oCACd,YAAY,WAAW;oCACvB,MAAM,uBAAuB,WAAW,kBAAkB;oCAC1D,sDAAsD;oCACtD,cAAc,cAAc,uBAAuB,uBAAuB;oCAC1E,YAAY,YAAY,uBAAuB,uBAAuB;oCACtE,UAAU,gBAAgB,CAAC,YAAY,aAAa,YAAY;gCAClE;gCAEA,sDAAsD;gCACtD,MAAM,wBAAwB;4BAChC;wBACF;oBACF;gBACF;YACF;QACF;IACF;IACA,OAAO,gBAAgB,CAAC,WAAW,SAAS;IAC5C,OAAO;QACL,OAAO,mBAAmB,CAAC,WAAW,SAAS;IACjD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3593, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Bhtml%400.33.1/node_modules/%40lexical/html/LexicalHtml.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, getRegisteredNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificialNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = getRegisteredNode(editor, target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificialNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;AAED;AACA;;;;AAGA;;;;;;CAMC,GAGD;;;;CAIC,GACD,SAAS,sBAAsB,MAAM,EAAE,GAAG;IACxC,MAAM,WAAW,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,UAAU,GAAG,EAAE;IACpD,IAAI,eAAe,EAAE;IACrB,MAAM,qBAAqB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACxC,MAAM,UAAU,QAAQ,CAAC,EAAE;QAC3B,IAAI,CAAC,YAAY,GAAG,CAAC,QAAQ,QAAQ,GAAG;YACtC,MAAM,cAAc,oBAAoB,SAAS,QAAQ,oBAAoB;YAC7E,IAAI,gBAAgB,MAAM;gBACxB,eAAe,aAAa,MAAM,CAAC;YACrC;QACF;IACF;IACA,uBAAuB;IACvB,OAAO;AACT;AACA,SAAS,uBAAuB,MAAM,EAAE,SAAS;IAC/C,IAAI,OAAO,aAAa,eAAe,OAAO,WAAW,eAAe,OAAO,OAAO,MAAM,KAAK,aAAa;QAC5G,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,YAAY,SAAS,aAAa,CAAC;IACzC,MAAM,OAAO,CAAA,GAAA,+LAAA,CAAA,WAAQ,AAAD;IACpB,MAAM,mBAAmB,KAAK,WAAW;IACzC,IAAK,IAAI,IAAI,GAAG,IAAI,iBAAiB,MAAM,EAAE,IAAK;QAChD,MAAM,eAAe,gBAAgB,CAAC,EAAE;QACxC,mBAAmB,QAAQ,cAAc,WAAW;IACtD;IACA,OAAO,UAAU,SAAS;AAC5B;AACA,SAAS,mBAAmB,MAAM,EAAE,WAAW,EAAE,aAAa,EAAE,YAAY,IAAI;IAC9E,IAAI,gBAAgB,cAAc,OAAO,YAAY,UAAU,CAAC,aAAa;IAC7E,MAAM,gBAAgB,CAAA,GAAA,+LAAA,CAAA,iBAAc,AAAD,EAAE,gBAAgB,YAAY,eAAe,CAAC;IACjF,IAAI,SAAS;IACb,IAAI,cAAc,MAAM;QACtB,IAAI,QAAQ,CAAA,GAAA,+LAAA,CAAA,uBAAoB,AAAD,EAAE;QACjC,QAAQ,CAAA,GAAA,+LAAA,CAAA,cAAW,AAAD,EAAE,UAAU,cAAc,OAAO,CAAA,GAAA,sPAAA,CAAA,gCAA6B,AAAD,EAAE,WAAW,SAAS;QACrG,SAAS;IACX;IACA,MAAM,WAAW,CAAA,GAAA,+LAAA,CAAA,iBAAc,AAAD,EAAE,UAAU,OAAO,WAAW,KAAK,EAAE;IACnE,MAAM,iBAAiB,CAAA,GAAA,+LAAA,CAAA,oBAAiB,AAAD,EAAE,QAAQ,OAAO,OAAO;IAC/D,IAAI;IAEJ,0CAA0C;IAC1C,IAAI,kBAAkB,eAAe,SAAS,KAAK,WAAW;QAC5D,eAAe,eAAe,SAAS,CAAC,QAAQ;IAClD,OAAO;QACL,eAAe,OAAO,SAAS,CAAC;IAClC;IACA,MAAM,EACJ,OAAO,EACP,KAAK,EACN,GAAG;IACJ,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IACA,MAAM,WAAW,SAAS,sBAAsB;IAChD,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACxC,MAAM,YAAY,QAAQ,CAAC,EAAE;QAC7B,MAAM,qBAAqB,mBAAmB,QAAQ,WAAW,UAAU;QAC3E,IAAI,CAAC,iBAAiB,CAAA,GAAA,+LAAA,CAAA,iBAAc,AAAD,EAAE,gBAAgB,sBAAsB,YAAY,gBAAgB,CAAC,WAAW,WAAW,SAAS;YACrI,gBAAgB;QAClB;IACF;IACA,IAAI,iBAAiB,CAAC,eAAe;QACnC,IAAI,CAAA,GAAA,+LAAA,CAAA,gBAAa,AAAD,EAAE,YAAY,CAAA,GAAA,+LAAA,CAAA,qBAAkB,AAAD,EAAE,UAAU;YACzD,QAAQ,MAAM,CAAC;QACjB;QACA,cAAc,MAAM,CAAC;QACrB,IAAI,OAAO;YACT,MAAM,aAAa,MAAM,IAAI,CAAC,QAAQ;YACtC,IAAI,YAAY;gBACd,IAAI,CAAA,GAAA,+LAAA,CAAA,qBAAkB,AAAD,EAAE,UAAU;oBAC/B,QAAQ,eAAe,CAAC;gBAC1B,OAAO;oBACL,QAAQ,WAAW,CAAC;gBACtB;YACF;QACF;IACF,OAAO;QACL,cAAc,MAAM,CAAC;IACvB;IACA,OAAO;AACT;AACA,SAAS,sBAAsB,OAAO,EAAE,MAAM;IAC5C,MAAM,EACJ,QAAQ,EACT,GAAG;IACJ,MAAM,oBAAoB,OAAO,gBAAgB,CAAC,GAAG,CAAC,SAAS,WAAW;IAC1E,IAAI,oBAAoB;IACxB,IAAI,sBAAsB,WAAW;QACnC,KAAK,MAAM,oBAAoB,kBAAmB;YAChD,MAAM,gBAAgB,iBAAiB;YACvC,IAAI,kBAAkB,QAAQ,CAAC,sBAAsB,QACrD,4DAA4D;YAC5D,wEAAwE;YACxE,CAAC,kBAAkB,QAAQ,IAAI,CAAC,KAAK,CAAC,cAAc,QAAQ,IAAI,CAAC,CAAC,GAAG;gBACnE,oBAAoB;YACtB;QACF;IACF;IACA,OAAO,sBAAsB,OAAO,kBAAkB,UAAU,GAAG;AACrE;AACA,MAAM,cAAc,IAAI,IAAI;IAAC;IAAS;CAAS;AAC/C,SAAS,oBAAoB,IAAI,EAAE,MAAM,EAAE,kBAAkB,EAAE,2BAA2B,EAAE,cAAc,IAAI,KAAK,EAAE,iBAAiB;IACpI,IAAI,eAAe,EAAE;IACrB,IAAI,YAAY,GAAG,CAAC,KAAK,QAAQ,GAAG;QAClC,OAAO;IACT;IACA,IAAI,qBAAqB;IACzB,MAAM,oBAAoB,sBAAsB,MAAM;IACtD,MAAM,kBAAkB,oBAAoB,kBAAkB,QAAQ;IACtE,IAAI,gBAAgB;IACpB,IAAI,oBAAoB,MAAM;QAC5B,gBAAgB,gBAAgB,KAAK;QACrC,MAAM,iBAAiB,gBAAgB,IAAI;QAC3C,qBAAqB,MAAM,OAAO,CAAC,kBAAkB,cAAc,CAAC,eAAe,MAAM,GAAG,EAAE,GAAG;QACjG,IAAI,uBAAuB,MAAM;YAC/B,KAAK,MAAM,GAAG,iBAAiB,IAAI,YAAa;gBAC9C,qBAAqB,iBAAiB,oBAAoB;gBAC1D,IAAI,CAAC,oBAAoB;oBACvB;gBACF;YACF;YACA,IAAI,oBAAoB;gBACtB,aAAa,IAAI,IAAK,MAAM,OAAO,CAAC,kBAAkB,iBAAiB;oBAAC;iBAAmB;YAC7F;QACF;QACA,IAAI,gBAAgB,QAAQ,IAAI,MAAM;YACpC,YAAY,GAAG,CAAC,KAAK,QAAQ,EAAE,gBAAgB,QAAQ;QACzD;IACF;IAEA,iEAAiE;IACjE,6DAA6D;IAC7D,MAAM,WAAW,KAAK,UAAU;IAChC,IAAI,oBAAoB,EAAE;IAC1B,MAAM,yCAAyC,sBAAsB,QAAQ,CAAA,GAAA,+LAAA,CAAA,sBAAmB,AAAD,EAAE,sBAAsB,QAAQ,sBAAsB,QAAQ,CAAA,GAAA,+LAAA,CAAA,sBAAmB,AAAD,EAAE,uBAAuB;IACxM,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACxC,kBAAkB,IAAI,IAAI,oBAAoB,QAAQ,CAAC,EAAE,EAAE,QAAQ,oBAAoB,wCAAwC,IAAI,IAAI,cAAc;IACvJ;IACA,IAAI,iBAAiB,MAAM;QACzB,oBAAoB,cAAc;IACpC;IACA,IAAI,CAAA,GAAA,+LAAA,CAAA,iBAAc,AAAD,EAAE,OAAO;QACxB,IAAI,CAAC,wCAAwC;YAC3C,oBAAoB,sBAAsB,MAAM,mBAAmB,+LAAA,CAAA,uBAAoB;QACzF,OAAO;YACL,oBAAoB,sBAAsB,MAAM,mBAAmB;gBACjE,MAAM,iBAAiB,IAAI,+LAAA,CAAA,6BAA0B;gBACrD,mBAAmB,IAAI,CAAC;gBACxB,OAAO;YACT;QACF;IACF;IACA,IAAI,sBAAsB,MAAM;QAC9B,IAAI,kBAAkB,MAAM,GAAG,GAAG;YAChC,sEAAsE;YACtE,8BAA8B;YAC9B,eAAe,aAAa,MAAM,CAAC;QACrC,OAAO;YACL,IAAI,CAAA,GAAA,+LAAA,CAAA,iBAAc,AAAD,EAAE,SAAS,+BAA+B,OAAO;gBAChE,6GAA6G;gBAC7G,eAAe,aAAa,MAAM,CAAC,CAAA,GAAA,+LAAA,CAAA,uBAAoB,AAAD;YACxD;QACF;IACF,OAAO;QACL,IAAI,CAAA,GAAA,+LAAA,CAAA,iBAAc,AAAD,EAAE,qBAAqB;YACtC,yDAAyD;YACzD,wCAAwC;YACxC,mBAAmB,MAAM,IAAI;QAC/B;IACF;IACA,OAAO;AACT;AACA,SAAS,sBAAsB,OAAO,EAAE,KAAK,EAAE,eAAe;IAC5D,MAAM,YAAY,QAAQ,KAAK,CAAC,SAAS;IACzC,MAAM,MAAM,EAAE;IACd,IAAI,oBAAoB,EAAE;IAC1B,6CAA6C;IAC7C,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACrC,MAAM,OAAO,KAAK,CAAC,EAAE;QACrB,IAAI,CAAA,GAAA,+LAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;YAC7B,IAAI,aAAa,CAAC,KAAK,SAAS,IAAI;gBAClC,KAAK,SAAS,CAAC;YACjB;YACA,IAAI,IAAI,CAAC;QACX,OAAO;YACL,kBAAkB,IAAI,CAAC;YACvB,IAAI,MAAM,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,MAAM,GAAG,KAAK,CAAA,GAAA,+LAAA,CAAA,sBAAmB,AAAD,EAAE,KAAK,CAAC,IAAI,EAAE,GAAG;gBACvF,MAAM,UAAU;gBAChB,QAAQ,SAAS,CAAC;gBAClB,QAAQ,MAAM,IAAI;gBAClB,IAAI,IAAI,CAAC;gBACT,oBAAoB,EAAE;YACxB;QACF;IACF;IACA,OAAO;AACT;AACA,SAAS,uBAAuB,kBAAkB;IAChD,KAAK,MAAM,QAAQ,mBAAoB;QACrC,IAAI,KAAK,cAAc,cAAc,+LAAA,CAAA,6BAA0B,EAAE;YAC/D,KAAK,WAAW,CAAC,CAAA,GAAA,+LAAA,CAAA,uBAAoB,AAAD;QACtC;IACF;IACA,6CAA6C;IAC7C,KAAK,MAAM,QAAQ,mBAAoB;QACrC,MAAM,WAAW,KAAK,WAAW;QACjC,KAAK,MAAM,SAAS,SAAU;YAC5B,KAAK,YAAY,CAAC;QACpB;QACA,KAAK,MAAM;IACb;AACF;AACA,SAAS,+BAA+B,IAAI;IAC1C,IAAI,KAAK,WAAW,IAAI,QAAQ,KAAK,eAAe,IAAI,MAAM;QAC5D,OAAO;IACT;IACA,OAAO,CAAA,GAAA,+LAAA,CAAA,kBAAe,AAAD,EAAE,KAAK,WAAW,KAAK,CAAA,GAAA,+LAAA,CAAA,kBAAe,AAAD,EAAE,KAAK,eAAe;AAClF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3842, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Bclipboard%400.33.1/node_modules/%40lexical/clipboard/LexicalClipboard.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $caretFromPoint, $isTextPointCaret, $getCaretRange, $getChildCaret, $getRoot, $isTextNode, $isElementNode, $parseSerializedNode, getDOMSelection, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  const plainString = dataTransfer.getData('text/plain');\n\n  // Skip HTML handling if it matches the plain text representation.\n  // This avoids unnecessary processing for plain text strings created by\n  // iOS Safari autocorrect, which incorrectly includes a `text/html` type.\n  if (htmlString && plainString !== htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = plainString || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n    $updateSelectionOnInsert(selection);\n  }\n  return;\n}\nfunction $updateSelectionOnInsert(selection) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n    let nodeToInspect = null;\n    const anchorCaret = $caretFromPoint(anchor, 'previous');\n    if (anchorCaret) {\n      if ($isTextPointCaret(anchorCaret)) {\n        nodeToInspect = anchorCaret.origin;\n      } else {\n        const range = $getCaretRange(anchorCaret, $getChildCaret($getRoot(), 'next').getFlipped());\n        for (const caret of range) {\n          if ($isTextNode(caret.origin)) {\n            nodeToInspect = caret.origin;\n            break;\n          } else if ($isElementNode(caret.origin) && !caret.origin.isInline()) {\n            break;\n          }\n        }\n      }\n    }\n    if (nodeToInspect && $isTextNode(nodeToInspect)) {\n      const newFormat = nodeToInspect.getFormat();\n      const newStyle = nodeToInspect.getStyle();\n      if (selection.format !== newFormat || selection.style !== newStyle) {\n        selection.format = newFormat;\n        selection.style = newStyle;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSerializedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const editorWindow = editor._window || window;\n  const windowDocument = window.document;\n  const domSelection = getDOMSelection(editorWindow);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4304, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Brich-text%400.33.1/node_modules/%40lexical/rich-text/LexicalRichText.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $insertDataTransferForRichText, copyToClipboard } from '@lexical/clipboard';\nimport { $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { addClassNamesToElement, isHTMLElement, objectKlassEquals, mergeRegister, $findMatchingParent, $getNearestBlockElementAncestorOrThrow } from '@lexical/utils';\nimport { createCommand, ElementNode, $createParagraphNode, $applyNodeReplacement, setNodeIndentFromDOM, CLICK_COMMAND, $getSelection, $isNodeSelection, COMMAND_PRIORITY_EDITOR, DELETE_CHARACTER_COMMAND, $isRangeSelection, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, $isElementNode, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, $insertNodes, $createTabNode, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, KEY_ARROW_UP_COMMAND, $getAdjacentNode, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, DROP_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $isTextNode, $normalizeSelection__EXPERIMENTAL, $setSelection, DRAGSTART_COMMAND, DRAGOVER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, isDOMNode, isSelectionCapturedInDecoratorInput, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, PASTE_TAG, $getRoot, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = createCommand('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createQuoteNode().updateFromJSON(serializedNode);\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = $createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return $applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setTag(tag) {\n    const self = this.getWritable();\n    this.__tag = tag;\n    return self;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    return prevNode.__tag !== this.__tag;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const lastDesc = this.getLastDescendant();\n    const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();\n    const newElement = isAtEnd || !selection ? $createParagraphNode() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = $createParagraphNode();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      setNodeIndentFromDOM(element, node);\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag = 'h1') {\n  return $applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const clipboardData = objectKlassEquals(event, InputEvent) || objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      $insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: PASTE_TAG\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    } else if ($isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if (objectKlassEquals(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if (objectKlassEquals(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = $getNearestNodeFromDOMNode(target);\n  return $isDecoratorNode(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === $getRoot().getChildrenSize();\n}\nfunction $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const {\n    anchor\n  } = selection;\n  if (anchor.offset !== 0) {\n    return false;\n  }\n  const anchorNode = anchor.getNode();\n  if ($isRootNode(anchorNode)) {\n    return false;\n  }\n  const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n  return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));\n}\n\n/**\n * Resets the capitalization of the selection to default.\n * Called when the user presses space, tab, or enter key.\n * @param selection The selection to reset the capitalization of.\n */\nfunction $resetCapitalization(selection) {\n  for (const format of ['lowercase', 'uppercase', 'capitalize']) {\n    if (selection.hasFormat(format)) {\n      selection.toggleFormat(format);\n    }\n  }\n}\nfunction registerRichText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(CLICK_COMMAND, payload => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.deleteCharacter(isBackward);\n      return true;\n    } else if ($isNodeSelection(selection)) {\n      selection.deleteNodes();\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if ($isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_TEXT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(FORMAT_ELEMENT_COMMAND, format => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = $findMatchingParent(node, parentNode => $isElementNode(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(Math.max(0, indent - 1));\n      }\n    });\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      const possibleNode = $getAdjacentNode(selection.focus, true);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ($isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = $getAdjacentNode(selection.focus, false);\n      if (!event.shiftKey && $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {\n        event.preventDefault();\n        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined);\n      }\n      // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.\n      // more details - https://github.com/facebook/lexical/issues/5841\n      if (IS_IOS && navigator.language === 'ko-KR') {\n        return false;\n      }\n    } else if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (!($isRangeSelection(selection) || $isNodeSelection(selection))) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    $resetCapitalization(selection);\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = $getNearestNodeFromDOMNode(domNode);\n        if (node !== null) {\n          const selection = $createRangeSelection();\n          if ($isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection);\n          $setSelection(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = $getSelection();\n    if (isFileTransfer && !$isRangeSelection(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = $getNearestNodeFromDOMNode(eventRange.node);\n      if ($isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if (isDOMNode(event.target) && isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_SPACE_COMMAND, _ => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_TAB_COMMAND, _ => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexport { $createHeadingNode, $createQuoteNode, $isHeadingNode, $isQuoteNode, DRAG_DROP_PASTE, HeadingNode, QuoteNode, eventFiles, registerRichText };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5118, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Bhistory%400.33.1/node_modules/%40lexical/history/LexicalHistory.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { mergeRegister } from '@lexical/utils';\nimport { UNDO_COMMAND, COMMAND_PRIORITY_EDITOR, REDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, HISTORIC_TAG, HISTORY_PUSH_TAG, HISTORY_MERGE_TAG, $isRangeSelection, $isTextNode, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!$isRangeSelection(nextSelection) || !$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!$isTextNode(prevDirtyNode) || !$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = $isRangeSelection(prevSelection) && $isRangeSelection(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && $isTextNode(prevNode) && $isTextNode(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has(HISTORIC_TAG)) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has(HISTORY_PUSH_TAG);\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has(HISTORY_MERGE_TAG);\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexport { createEmptyHistoryState, registerHistory };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5406, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Blist%400.33.1/node_modules/%40lexical/list/LexicalList.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister, $findMatchingParent, calculateZoomLevel } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $createParagraphNode, $isElementNode, $isLeafNode, $setPointFromCaret, $normalizeCaret, $getChildCaret, ElementNode, buildImportMap, $isParagraphNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ESCAPE_COMMAND, KEY_SPACE_COMMAND, $getNearestNodeFromDOMNode, KEY_ARROW_LEFT_COMMAND, getNearestEditorFromDOMNode, $getNodeByKey, INSERT_PARAGRAPH_COMMAND, $isTextNode, TextNode } from 'lexical';\nimport { getStyleObjectFromCSS } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = $getSelection();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ($isRangeSelection(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isRootOrShadowRoot(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = $createParagraphNode();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ($isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ($isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = $isLeafNode(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = $getSelection();\n  if ($isRangeSelection(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isLeafNode(node)) {\n          const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = $createParagraphNode().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          $setPointFromCaret(selection.anchor, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          $setPointFromCaret(selection.focus, $normalizeCaret($getChildCaret(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = getStyleObjectFromCSS(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in getStyleObjectFromCSS(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || $isParagraphNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: ElementNode,\n      importDOM: buildImportMap({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if (isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append($isElementNode(node) && !($isListNode(node) || node.isInline()) ? $createTextNode(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return mergeRegister(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = $getNearestNodeFromDOMNode(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = $findMatchingParent(anchorNode, node => $isElementNode(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!isHTMLElement(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if (isHTMLElement(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = calculateZoomLevel(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if (isHTMLElement(event.target)) {\n      const domNode = event.target;\n      const editor = getNearestEditorFromDOMNode(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = $getNearestNodeFromDOMNode(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return isHTMLElement(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = $getNearestNodeFromDOMNode(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = createCommand('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = $getNodeByKey(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ($isTextNode(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = $getSelection();\n      if ($isRangeSelection(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = $findMatchingParent(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $insertList, $isListItemNode, $isListNode, $removeList, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, UPDATE_LIST_START_COMMAND, insertList, registerCheckList, registerList, registerListStrictIndentTransform, removeList };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6927, "column": 0}, "map": {"version":3,"file":"index.module.js","sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/hooks/useEventCallback.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/utils/clamp.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/common/Interactive.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/utils/format.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/common/Pointer.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/utils/round.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/utils/convert.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/common/Hue.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/common/Saturation.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/utils/compare.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/hooks/useColorManipulation.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/utils/nonce.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/hooks/useIsomorphicLayoutEffect.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/hooks/useStyleSheet.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/common/ColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HexColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/common/Alpha.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/common/AlphaColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HexAlphaColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HslaColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HslaStringColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HslColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HslStringColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HsvaColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HsvaStringColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HsvColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HsvStringColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/RgbaColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/RgbaStringColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/RgbColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/RgbStringColorPicker.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/utils/validate.ts","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/common/ColorInput.tsx","file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/react-colorful%405.6.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/react-colorful/src/components/HexColorInput.tsx"],"sourcesContent":["import { useRef } from \"react\";\n\n// Saves incoming handler to the ref in order to avoid \"useCallback hell\"\nexport function useEventCallback<T>(handler?: (value: T) => void): (value: T) => void {\n  const callbackRef = useRef(handler);\n  const fn = useRef((value: T) => {\n    callbackRef.current && callbackRef.current(value);\n  });\n  callbackRef.current = handler;\n\n  return fn.current;\n}\n","// Clamps a value between an upper and lower bound.\n// We use ternary operators because it makes the minified code\n// 2 times shorter then `Math.min(Math.max(a,b),c)`\nexport const clamp = (number: number, min = 0, max = 1): number => {\n  return number > max ? max : number < min ? min : number;\n};\n","import React, { useRef, useMemo, useEffect } from \"react\";\n\nimport { useEventCallback } from \"../../hooks/useEventCallback\";\nimport { clamp } from \"../../utils/clamp\";\n\nexport interface Interaction {\n  left: number;\n  top: number;\n}\n\n// Check if an event was triggered by touch\nconst isTouch = (event: MouseEvent | TouchEvent): event is TouchEvent => \"touches\" in event;\n\n// Finds a proper touch point by its identifier\nconst getTouchPoint = (touches: TouchList, touchId: null | number): Touch => {\n  for (let i = 0; i < touches.length; i++) {\n    if (touches[i].identifier === touchId) return touches[i];\n  }\n  return touches[0];\n};\n\n// Finds the proper window object to fix iframe embedding issues\nconst getParentWindow = (node?: HTMLDivElement | null): Window => {\n  return (node && node.ownerDocument.defaultView) || self;\n};\n\n// Returns a relative position of the pointer inside the node's bounding box\nconst getRelativePosition = (\n  node: HTMLDivElement,\n  event: MouseEvent | TouchEvent,\n  touchId: null | number\n): Interaction => {\n  const rect = node.getBoundingClientRect();\n\n  // Get user's pointer position from `touches` array if it's a `TouchEvent`\n  const pointer = isTouch(event) ? getTouchPoint(event.touches, touchId) : (event as MouseEvent);\n\n  return {\n    left: clamp((pointer.pageX - (rect.left + getParentWindow(node).pageXOffset)) / rect.width),\n    top: clamp((pointer.pageY - (rect.top + getParentWindow(node).pageYOffset)) / rect.height),\n  };\n};\n\n// Browsers introduced an intervention, making touch events passive by default.\n// This workaround removes `preventDefault` call from the touch handlers.\n// https://github.com/facebook/react/issues/19651\nconst preventDefaultMove = (event: MouseEvent | TouchEvent): void => {\n  !isTouch(event) && event.preventDefault();\n};\n\n// Prevent mobile browsers from handling mouse events (conflicting with touch ones).\n// If we detected a touch interaction before, we prefer reacting to touch events only.\nconst isInvalid = (event: MouseEvent | TouchEvent, hasTouch: boolean): boolean => {\n  return hasTouch && !isTouch(event);\n};\n\ninterface Props {\n  onMove: (interaction: Interaction) => void;\n  onKey: (offset: Interaction) => void;\n  children: React.ReactNode;\n}\n\nconst InteractiveBase = ({ onMove, onKey, ...rest }: Props) => {\n  const container = useRef<HTMLDivElement>(null);\n  const onMoveCallback = useEventCallback<Interaction>(onMove);\n  const onKeyCallback = useEventCallback<Interaction>(onKey);\n  const touchId = useRef<null | number>(null);\n  const hasTouch = useRef(false);\n\n  const [handleMoveStart, handleKeyDown, toggleDocumentEvents] = useMemo(() => {\n    const handleMoveStart = ({ nativeEvent }: React.MouseEvent | React.TouchEvent) => {\n      const el = container.current;\n      if (!el) return;\n\n      // Prevent text selection\n      preventDefaultMove(nativeEvent);\n\n      if (isInvalid(nativeEvent, hasTouch.current) || !el) return;\n\n      if (isTouch(nativeEvent)) {\n        hasTouch.current = true;\n        const changedTouches = nativeEvent.changedTouches || [];\n        if (changedTouches.length) touchId.current = changedTouches[0].identifier;\n      }\n\n      el.focus();\n      onMoveCallback(getRelativePosition(el, nativeEvent, touchId.current));\n      toggleDocumentEvents(true);\n    };\n\n    const handleMove = (event: MouseEvent | TouchEvent) => {\n      // Prevent text selection\n      preventDefaultMove(event);\n\n      // If user moves the pointer outside of the window or iframe bounds and release it there,\n      // `mouseup`/`touchend` won't be fired. In order to stop the picker from following the cursor\n      // after the user has moved the mouse/finger back to the document, we check `event.buttons`\n      // and `event.touches`. It allows us to detect that the user is just moving his pointer\n      // without pressing it down\n      const isDown = isTouch(event) ? event.touches.length > 0 : event.buttons > 0;\n\n      if (isDown && container.current) {\n        onMoveCallback(getRelativePosition(container.current, event, touchId.current));\n      } else {\n        toggleDocumentEvents(false);\n      }\n    };\n\n    const handleMoveEnd = () => toggleDocumentEvents(false);\n\n    const handleKeyDown = (event: React.KeyboardEvent) => {\n      const keyCode = event.which || event.keyCode;\n\n      // Ignore all keys except arrow ones\n      if (keyCode < 37 || keyCode > 40) return;\n      // Do not scroll page by arrow keys when document is focused on the element\n      event.preventDefault();\n      // Send relative offset to the parent component.\n      // We use codes (37, 38, 39, 40) instead of keys ('ArrowRight', 'ArrowDown', etc)\n      // to reduce the size of the library\n      onKeyCallback({\n        left: keyCode === 39 ? 0.05 : keyCode === 37 ? -0.05 : 0,\n        top: keyCode === 40 ? 0.05 : keyCode === 38 ? -0.05 : 0,\n      });\n    };\n\n    function toggleDocumentEvents(state?: boolean) {\n      const touch = hasTouch.current;\n      const el = container.current;\n      const parentWindow = getParentWindow(el);\n\n      // Add or remove additional pointer event listeners\n      const toggleEvent = state ? parentWindow.addEventListener : parentWindow.removeEventListener;\n      toggleEvent(touch ? \"touchmove\" : \"mousemove\", handleMove);\n      toggleEvent(touch ? \"touchend\" : \"mouseup\", handleMoveEnd);\n    }\n\n    return [handleMoveStart, handleKeyDown, toggleDocumentEvents];\n  }, [onKeyCallback, onMoveCallback]);\n\n  // Remove window event listeners before unmounting\n  useEffect(() => toggleDocumentEvents, [toggleDocumentEvents]);\n\n  return (\n    <div\n      {...rest}\n      onTouchStart={handleMoveStart}\n      onMouseDown={handleMoveStart}\n      className=\"react-colorful__interactive\"\n      ref={container}\n      onKeyDown={handleKeyDown}\n      tabIndex={0}\n      role=\"slider\"\n    />\n  );\n};\n\nexport const Interactive = React.memo(InteractiveBase);\n","export const formatClassName = (names: unknown[]): string => names.filter(Boolean).join(\" \");\n","import React from \"react\";\nimport { formatClassName } from \"../../utils/format\";\n\ninterface Props {\n  className?: string;\n  top?: number;\n  left: number;\n  color: string;\n}\n\nexport const Pointer = ({ className, color, left, top = 0.5 }: Props): JSX.Element => {\n  const nodeClassName = formatClassName([\"react-colorful__pointer\", className]);\n\n  const style = {\n    top: `${top * 100}%`,\n    left: `${left * 100}%`,\n  };\n\n  return (\n    <div className={nodeClassName} style={style}>\n      <div className=\"react-colorful__pointer-fill\" style={{ backgroundColor: color }} />\n    </div>\n  );\n};\n","export const round = (number: number, digits = 0, base = Math.pow(10, digits)): number => {\n  return Math.round(base * number) / base;\n};\n","import { round } from \"./round\";\nimport { RgbaColor, RgbColor, HslaColor, HslColor, HsvaColor, HsvColor } from \"../types\";\n\n/**\n * Valid CSS <angle> units.\n * https://developer.mozilla.org/en-US/docs/Web/CSS/angle\n */\nconst angleUnits: Record<string, number> = {\n  grad: 360 / 400,\n  turn: 360,\n  rad: 360 / (Math.PI * 2),\n};\n\nexport const hexToHsva = (hex: string): HsvaColor => rgbaToHsva(hexToRgba(hex));\n\nexport const hexToRgba = (hex: string): RgbaColor => {\n  if (hex[0] === \"#\") hex = hex.substring(1);\n\n  if (hex.length < 6) {\n    return {\n      r: parseInt(hex[0] + hex[0], 16),\n      g: parseInt(hex[1] + hex[1], 16),\n      b: parseInt(hex[2] + hex[2], 16),\n      a: hex.length === 4 ? round(parseInt(hex[3] + hex[3], 16) / 255, 2) : 1,\n    };\n  }\n\n  return {\n    r: parseInt(hex.substring(0, 2), 16),\n    g: parseInt(hex.substring(2, 4), 16),\n    b: parseInt(hex.substring(4, 6), 16),\n    a: hex.length === 8 ? round(parseInt(hex.substring(6, 8), 16) / 255, 2) : 1,\n  };\n};\n\nexport const parseHue = (value: string, unit = \"deg\"): number => {\n  return Number(value) * (angleUnits[unit] || 1);\n};\n\nexport const hslaStringToHsva = (hslString: string): HsvaColor => {\n  const matcher = /hsla?\\(?\\s*(-?\\d*\\.?\\d+)(deg|rad|grad|turn)?[,\\s]+(-?\\d*\\.?\\d+)%?[,\\s]+(-?\\d*\\.?\\d+)%?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\n  const match = matcher.exec(hslString);\n\n  if (!match) return { h: 0, s: 0, v: 0, a: 1 };\n\n  return hslaToHsva({\n    h: parseHue(match[1], match[2]),\n    s: Number(match[3]),\n    l: Number(match[4]),\n    a: match[5] === undefined ? 1 : Number(match[5]) / (match[6] ? 100 : 1),\n  });\n};\n\nexport const hslStringToHsva = hslaStringToHsva;\n\nexport const hslaToHsva = ({ h, s, l, a }: HslaColor): HsvaColor => {\n  s *= (l < 50 ? l : 100 - l) / 100;\n\n  return {\n    h: h,\n    s: s > 0 ? ((2 * s) / (l + s)) * 100 : 0,\n    v: l + s,\n    a,\n  };\n};\n\nexport const hsvaToHex = (hsva: HsvaColor): string => rgbaToHex(hsvaToRgba(hsva));\n\nexport const hsvaToHsla = ({ h, s, v, a }: HsvaColor): HslaColor => {\n  const hh = ((200 - s) * v) / 100;\n\n  return {\n    h: round(h),\n    s: round(hh > 0 && hh < 200 ? ((s * v) / 100 / (hh <= 100 ? hh : 200 - hh)) * 100 : 0),\n    l: round(hh / 2),\n    a: round(a, 2),\n  };\n};\n\nexport const hsvaToHslString = (hsva: HsvaColor): string => {\n  const { h, s, l } = hsvaToHsla(hsva);\n  return `hsl(${h}, ${s}%, ${l}%)`;\n};\n\nexport const hsvaToHsvString = (hsva: HsvaColor): string => {\n  const { h, s, v } = roundHsva(hsva);\n  return `hsv(${h}, ${s}%, ${v}%)`;\n};\n\nexport const hsvaToHsvaString = (hsva: HsvaColor): string => {\n  const { h, s, v, a } = roundHsva(hsva);\n  return `hsva(${h}, ${s}%, ${v}%, ${a})`;\n};\n\nexport const hsvaToHslaString = (hsva: HsvaColor): string => {\n  const { h, s, l, a } = hsvaToHsla(hsva);\n  return `hsla(${h}, ${s}%, ${l}%, ${a})`;\n};\n\nexport const hsvaToRgba = ({ h, s, v, a }: HsvaColor): RgbaColor => {\n  h = (h / 360) * 6;\n  s = s / 100;\n  v = v / 100;\n\n  const hh = Math.floor(h),\n    b = v * (1 - s),\n    c = v * (1 - (h - hh) * s),\n    d = v * (1 - (1 - h + hh) * s),\n    module = hh % 6;\n\n  return {\n    r: round([v, c, b, b, d, v][module] * 255),\n    g: round([d, v, v, c, b, b][module] * 255),\n    b: round([b, b, d, v, v, c][module] * 255),\n    a: round(a, 2),\n  };\n};\n\nexport const hsvaToRgbString = (hsva: HsvaColor): string => {\n  const { r, g, b } = hsvaToRgba(hsva);\n  return `rgb(${r}, ${g}, ${b})`;\n};\n\nexport const hsvaToRgbaString = (hsva: HsvaColor): string => {\n  const { r, g, b, a } = hsvaToRgba(hsva);\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n};\n\nexport const hsvaStringToHsva = (hsvString: string): HsvaColor => {\n  const matcher = /hsva?\\(?\\s*(-?\\d*\\.?\\d+)(deg|rad|grad|turn)?[,\\s]+(-?\\d*\\.?\\d+)%?[,\\s]+(-?\\d*\\.?\\d+)%?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\n  const match = matcher.exec(hsvString);\n\n  if (!match) return { h: 0, s: 0, v: 0, a: 1 };\n\n  return roundHsva({\n    h: parseHue(match[1], match[2]),\n    s: Number(match[3]),\n    v: Number(match[4]),\n    a: match[5] === undefined ? 1 : Number(match[5]) / (match[6] ? 100 : 1),\n  });\n};\n\nexport const hsvStringToHsva = hsvaStringToHsva;\n\nexport const rgbaStringToHsva = (rgbaString: string): HsvaColor => {\n  const matcher = /rgba?\\(?\\s*(-?\\d*\\.?\\d+)(%)?[,\\s]+(-?\\d*\\.?\\d+)(%)?[,\\s]+(-?\\d*\\.?\\d+)(%)?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\n  const match = matcher.exec(rgbaString);\n\n  if (!match) return { h: 0, s: 0, v: 0, a: 1 };\n\n  return rgbaToHsva({\n    r: Number(match[1]) / (match[2] ? 100 / 255 : 1),\n    g: Number(match[3]) / (match[4] ? 100 / 255 : 1),\n    b: Number(match[5]) / (match[6] ? 100 / 255 : 1),\n    a: match[7] === undefined ? 1 : Number(match[7]) / (match[8] ? 100 : 1),\n  });\n};\n\nexport const rgbStringToHsva = rgbaStringToHsva;\n\nconst format = (number: number) => {\n  const hex = number.toString(16);\n  return hex.length < 2 ? \"0\" + hex : hex;\n};\n\nexport const rgbaToHex = ({ r, g, b, a }: RgbaColor): string => {\n  const alphaHex = a < 1 ? format(round(a * 255)) : \"\";\n  return \"#\" + format(r) + format(g) + format(b) + alphaHex;\n};\n\nexport const rgbaToHsva = ({ r, g, b, a }: RgbaColor): HsvaColor => {\n  const max = Math.max(r, g, b);\n  const delta = max - Math.min(r, g, b);\n\n  // prettier-ignore\n  const hh = delta\n    ? max === r\n      ? (g - b) / delta\n      : max === g\n        ? 2 + (b - r) / delta\n        : 4 + (r - g) / delta\n    : 0;\n\n  return {\n    h: round(60 * (hh < 0 ? hh + 6 : hh)),\n    s: round(max ? (delta / max) * 100 : 0),\n    v: round((max / 255) * 100),\n    a,\n  };\n};\n\nexport const roundHsva = (hsva: HsvaColor): HsvaColor => ({\n  h: round(hsva.h),\n  s: round(hsva.s),\n  v: round(hsva.v),\n  a: round(hsva.a, 2),\n});\n\nexport const rgbaToRgb = ({ r, g, b }: RgbaColor): RgbColor => ({ r, g, b });\n\nexport const hslaToHsl = ({ h, s, l }: HslaColor): HslColor => ({ h, s, l });\n\nexport const hsvaToHsv = (hsva: HsvaColor): HsvColor => {\n  const { h, s, v } = roundHsva(hsva);\n  return { h, s, v };\n};\n","import React from \"react\";\n\nimport { Interactive, Interaction } from \"./Interactive\";\nimport { Pointer } from \"./Pointer\";\n\nimport { hsvaToHslString } from \"../../utils/convert\";\nimport { formatClassName } from \"../../utils/format\";\nimport { clamp } from \"../../utils/clamp\";\nimport { round } from \"../../utils/round\";\n\ninterface Props {\n  className?: string;\n  hue: number;\n  onChange: (newHue: { h: number }) => void;\n}\n\nconst HueBase = ({ className, hue, onChange }: Props) => {\n  const handleMove = (interaction: Interaction) => {\n    onChange({ h: 360 * interaction.left });\n  };\n\n  const handleKey = (offset: Interaction) => {\n    // Hue measured in degrees of the color circle ranging from 0 to 360\n    onChange({\n      h: clamp(hue + offset.left * 360, 0, 360),\n    });\n  };\n\n  const nodeClassName = formatClassName([\"react-colorful__hue\", className]);\n\n  return (\n    <div className={nodeClassName}>\n      <Interactive\n        onMove={handleMove}\n        onKey={handleKey}\n        aria-label=\"Hue\"\n        aria-valuenow={round(hue)}\n        aria-valuemax=\"360\"\n        aria-valuemin=\"0\"\n      >\n        <Pointer\n          className=\"react-colorful__hue-pointer\"\n          left={hue / 360}\n          color={hsvaToHslString({ h: hue, s: 100, v: 100, a: 1 })}\n        />\n      </Interactive>\n    </div>\n  );\n};\n\nexport const Hue = React.memo(HueBase);\n","import React from \"react\";\nimport { Interactive, Interaction } from \"./Interactive\";\nimport { Pointer } from \"./Pointer\";\nimport { HsvaColor } from \"../../types\";\nimport { hsvaToHslString } from \"../../utils/convert\";\nimport { clamp } from \"../../utils/clamp\";\nimport { round } from \"../../utils/round\";\n\ninterface Props {\n  hsva: HsvaColor;\n  onChange: (newColor: { s: number; v: number }) => void;\n}\n\nconst SaturationBase = ({ hsva, onChange }: Props) => {\n  const handleMove = (interaction: Interaction) => {\n    onChange({\n      s: interaction.left * 100,\n      v: 100 - interaction.top * 100,\n    });\n  };\n\n  const handleKey = (offset: Interaction) => {\n    // Saturation and brightness always fit into [0, 100] range\n    onChange({\n      s: clamp(hsva.s + offset.left * 100, 0, 100),\n      v: clamp(hsva.v - offset.top * 100, 0, 100),\n    });\n  };\n\n  const containerStyle = {\n    backgroundColor: hsvaToHslString({ h: hsva.h, s: 100, v: 100, a: 1 }),\n  };\n\n  return (\n    <div className=\"react-colorful__saturation\" style={containerStyle}>\n      <Interactive\n        onMove={handleMove}\n        onKey={handleKey}\n        aria-label=\"Color\"\n        aria-valuetext={`Saturation ${round(hsva.s)}%, Brightness ${round(hsva.v)}%`}\n      >\n        <Pointer\n          className=\"react-colorful__saturation-pointer\"\n          top={1 - hsva.v / 100}\n          left={hsva.s / 100}\n          color={hsvaToHslString(hsva)}\n        />\n      </Interactive>\n    </div>\n  );\n};\n\nexport const Saturation = React.memo(SaturationBase);\n","import { hexToRgba } from \"./convert\";\nimport { ObjectColor } from \"../types\";\n\nexport const equalColorObjects = (first: ObjectColor, second: ObjectColor): boolean => {\n  if (first === second) return true;\n\n  for (const prop in first) {\n    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)\n    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)\n    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,\n    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if\n    // there is or not), and then as a type TS can iterate over.\n    if (\n      ((first as unknown) as Record<string, number>)[prop] !==\n      ((second as unknown) as Record<string, number>)[prop]\n    )\n      return false;\n  }\n\n  return true;\n};\n\nexport const equalColorString = (first: string, second: string): boolean => {\n  return first.replace(/\\s/g, \"\") === second.replace(/\\s/g, \"\");\n};\n\nexport const equalHex = (first: string, second: string): boolean => {\n  if (first.toLowerCase() === second.toLowerCase()) return true;\n\n  // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects\n  return equalColorObjects(hexToRgba(first), hexToRgba(second));\n};\n","import { useState, useEffect, useCallback, useRef } from \"react\";\nimport { ColorModel, AnyColor, HsvaColor } from \"../types\";\nimport { equalColorObjects } from \"../utils/compare\";\nimport { useEventCallback } from \"./useEventCallback\";\n\nexport function useColorManipulation<T extends AnyColor>(\n  colorModel: ColorModel<T>,\n  color: T,\n  onChange?: (color: T) => void\n): [HsvaColor, (color: Partial<HsvaColor>) => void] {\n  // Save onChange callback in the ref for avoiding \"useCallback hell\"\n  const onChangeCallback = useEventCallback<T>(onChange);\n\n  // No matter which color model is used (HEX, RGB(A) or HSL(A)),\n  // all internal calculations are based on HSVA model\n  const [hsva, updateHsva] = useState<HsvaColor>(() => colorModel.toHsva(color));\n\n  // By using this ref we're able to prevent extra updates\n  // and the effects recursion during the color conversion\n  const cache = useRef({ color, hsva });\n\n  // Update local HSVA-value if `color` property value is changed,\n  // but only if that's not the same color that we just sent to the parent\n  useEffect(() => {\n    if (!colorModel.equal(color, cache.current.color)) {\n      const newHsva = colorModel.toHsva(color);\n      cache.current = { hsva: newHsva, color };\n      updateHsva(newHsva);\n    }\n  }, [color, colorModel]);\n\n  // Trigger `onChange` callback only if an updated color is different from cached one;\n  // save the new color to the ref to prevent unnecessary updates\n  useEffect(() => {\n    let newColor;\n    if (\n      !equalColorObjects(hsva, cache.current.hsva) &&\n      !colorModel.equal((newColor = colorModel.fromHsva(hsva)), cache.current.color)\n    ) {\n      cache.current = { hsva, color: newColor };\n      onChangeCallback(newColor);\n    }\n  }, [hsva, colorModel, onChangeCallback]);\n\n  // Merge the current HSVA color object with updated params.\n  // For example, when a child component sends `h` or `s` only\n  const handleChange = useCallback((params: Partial<HsvaColor>) => {\n    updateHsva((current) => Object.assign({}, current, params));\n  }, []);\n\n  return [hsva, handleChange];\n}\n","declare const __webpack_nonce__: string | undefined;\nlet nonce: string | undefined;\n\n/**\n * Returns a nonce hash included by Webpack or the one defined manually by developer.\n * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce\n * https://webpack.js.org/guides/csp/\n */\nexport const getNonce = (): string | undefined => {\n  if (nonce) return nonce;\n  if (typeof __webpack_nonce__ !== \"undefined\") return __webpack_nonce__;\n  return undefined;\n};\n\n/**\n * Signs the style tag with a base64-encoded string (nonce) to conforms to Content Security Policies.\n * This function has to be invoked before any picker is rendered if you aren't using Webpack for CSP.\n */\nexport const setNonce = (hash: string): void => {\n  nonce = hash;\n};\n","import { useLayoutEffect, useEffect } from \"react\";\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { RefObject } from \"react\";\n\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { getNonce } from \"../utils/nonce\";\n\n// Bundler is configured to load this as a processed minified CSS-string\nimport styles from \"../css/styles.css\";\n\nconst styleElementMap: Map<Document, HTMLStyleElement> = new Map();\n\n/**\n * Injects CSS code into the document's <head>\n */\nexport const useStyleSheet = (nodeRef: RefObject<HTMLDivElement>): void => {\n  useIsomorphicLayoutEffect(() => {\n    const parentDocument = nodeRef.current ? nodeRef.current.ownerDocument : document;\n\n    if (typeof parentDocument !== \"undefined\" && !styleElementMap.has(parentDocument)) {\n      const styleElement = parentDocument.createElement(\"style\");\n      styleElement.innerHTML = styles;\n      styleElementMap.set(parentDocument, styleElement);\n\n      // Conform to CSP rules by setting `nonce` attribute to the inline styles\n      const nonce = getNonce();\n      if (nonce) styleElement.setAttribute(\"nonce\", nonce);\n\n      parentDocument.head.appendChild(styleElement);\n    }\n  }, []);\n};\n","import React, { useRef } from \"react\";\n\nimport { Hue } from \"./Hue\";\nimport { Saturation } from \"./Saturation\";\n\nimport { ColorModel, ColorPickerBaseProps, AnyColor } from \"../../types\";\nimport { useColorManipulation } from \"../../hooks/useColorManipulation\";\nimport { useStyleSheet } from \"../../hooks/useStyleSheet\";\nimport { formatClassName } from \"../../utils/format\";\n\ninterface Props<T extends AnyColor> extends Partial<ColorPickerBaseProps<T>> {\n  colorModel: ColorModel<T>;\n}\n\nexport const ColorPicker = <T extends AnyColor>({\n  className,\n  colorModel,\n  color = colorModel.defaultColor,\n  onChange,\n  ...rest\n}: Props<T>): JSX.Element => {\n  const nodeRef = useRef<HTMLDivElement>(null);\n  useStyleSheet(nodeRef);\n\n  const [hsva, updateHsva] = useColorManipulation<T>(colorModel, color, onChange);\n\n  const nodeClassName = formatClassName([\"react-colorful\", className]);\n\n  return (\n    <div {...rest} ref={nodeRef} className={nodeClassName}>\n      <Saturation hsva={hsva} onChange={updateHsva} />\n      <Hue hue={hsva.h} onChange={updateHsva} className=\"react-colorful__last-control\" />\n    </div>\n  );\n};\n","import React from \"react\";\n\nimport { ColorPicker } from \"./common/ColorPicker\";\nimport { ColorModel, ColorPickerBaseProps } from \"../types\";\nimport { equalHex } from \"../utils/compare\";\nimport { hexToHsva, hsvaToHex } from \"../utils/convert\";\n\nconst colorModel: ColorModel<string> = {\n  defaultColor: \"000\",\n  toHsva: hexToHsva,\n  fromHsva: ({ h, s, v }) => hsvaToHex({ h, s, v, a: 1 }),\n  equal: equalHex,\n};\n\nexport const HexColorPicker = (props: Partial<ColorPickerBaseProps<string>>): JSX.Element => (\n  <ColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { Interactive, Interaction } from \"./Interactive\";\nimport { Pointer } from \"./Pointer\";\n\nimport { hsvaToHslaString } from \"../../utils/convert\";\nimport { formatClassName } from \"../../utils/format\";\nimport { clamp } from \"../../utils/clamp\";\nimport { round } from \"../../utils/round\";\nimport { HsvaColor } from \"../../types\";\n\ninterface Props {\n  className?: string;\n  hsva: HsvaColor;\n  onChange: (newAlpha: { a: number }) => void;\n}\n\nexport const Alpha = ({ className, hsva, onChange }: Props): JSX.Element => {\n  const handleMove = (interaction: Interaction) => {\n    onChange({ a: interaction.left });\n  };\n\n  const handleKey = (offset: Interaction) => {\n    // Alpha always fit into [0, 1] range\n    onChange({ a: clamp(hsva.a + offset.left) });\n  };\n\n  // We use `Object.assign` instead of the spread operator\n  // to prevent adding the polyfill (about 150 bytes gzipped)\n  const colorFrom = hsvaToHslaString(Object.assign({}, hsva, { a: 0 }));\n  const colorTo = hsvaToHslaString(Object.assign({}, hsva, { a: 1 }));\n\n  const gradientStyle = {\n    backgroundImage: `linear-gradient(90deg, ${colorFrom}, ${colorTo})`,\n  };\n\n  const nodeClassName = formatClassName([\"react-colorful__alpha\", className]);\n  const ariaValue = round(hsva.a * 100);\n\n  return (\n    <div className={nodeClassName}>\n      <div className=\"react-colorful__alpha-gradient\" style={gradientStyle} />\n      <Interactive\n        onMove={handleMove}\n        onKey={handleKey}\n        aria-label=\"Alpha\"\n        aria-valuetext={`${ariaValue}%`}\n        aria-valuenow={ariaValue}\n        aria-valuemin=\"0\"\n        aria-valuemax=\"100\"\n      >\n        <Pointer\n          className=\"react-colorful__alpha-pointer\"\n          left={hsva.a}\n          color={hsvaToHslaString(hsva)}\n        />\n      </Interactive>\n    </div>\n  );\n};\n","import React, { useRef } from \"react\";\n\nimport { Hue } from \"./Hue\";\nimport { Saturation } from \"./Saturation\";\nimport { Alpha } from \"./Alpha\";\n\nimport { ColorModel, ColorPickerBaseProps, AnyColor } from \"../../types\";\nimport { useColorManipulation } from \"../../hooks/useColorManipulation\";\nimport { useStyleSheet } from \"../../hooks/useStyleSheet\";\nimport { formatClassName } from \"../../utils/format\";\n\ninterface Props<T extends AnyColor> extends Partial<ColorPickerBaseProps<T>> {\n  colorModel: ColorModel<T>;\n}\n\nexport const AlphaColorPicker = <T extends AnyColor>({\n  className,\n  colorModel,\n  color = colorModel.defaultColor,\n  onChange,\n  ...rest\n}: Props<T>): JSX.Element => {\n  const nodeRef = useRef<HTMLDivElement>(null);\n  useStyleSheet(nodeRef);\n\n  const [hsva, updateHsva] = useColorManipulation<T>(colorModel, color, onChange);\n\n  const nodeClassName = formatClassName([\"react-colorful\", className]);\n\n  return (\n    <div {...rest} ref={nodeRef} className={nodeClassName}>\n      <Saturation hsva={hsva} onChange={updateHsva} />\n      <Hue hue={hsva.h} onChange={updateHsva} />\n      <Alpha hsva={hsva} onChange={updateHsva} className=\"react-colorful__last-control\" />\n    </div>\n  );\n};\n","import React from \"react\";\n\nimport { AlphaColorPicker } from \"./common/AlphaColorPicker\";\nimport { ColorModel, ColorPickerBaseProps } from \"../types\";\nimport { equalHex } from \"../utils/compare\";\nimport { hexToHsva, hsvaToHex } from \"../utils/convert\";\n\nconst colorModel: ColorModel<string> = {\n  defaultColor: \"0001\",\n  toHsva: hexToHsva,\n  fromHsva: hsvaToHex,\n  equal: equalHex,\n};\n\nexport const HexAlphaColorPicker = (props: Partial<ColorPickerBaseProps<string>>): JSX.Element => (\n  <AlphaColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { AlphaColorPicker } from \"./common/AlphaColorPicker\";\nimport { ColorModel, ColorPickerBaseProps, HslaColor } from \"../types\";\nimport { equalColorObjects } from \"../utils/compare\";\nimport { hslaToHsva, hsvaToHsla } from \"../utils/convert\";\n\nconst colorModel: ColorModel<HslaColor> = {\n  defaultColor: { h: 0, s: 0, l: 0, a: 1 },\n  toHsva: hslaToHsva,\n  fromHsva: hsvaToHsla,\n  equal: equalColorObjects,\n};\n\nexport const HslaColorPicker = (props: Partial<ColorPickerBaseProps<HslaColor>>): JSX.Element => (\n  <AlphaColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { AlphaColorPicker } from \"./common/AlphaColorPicker\";\nimport { ColorModel, ColorPickerBaseProps } from \"../types\";\nimport { equalColorString } from \"../utils/compare\";\nimport { hslaStringToHsva, hsvaToHslaString } from \"../utils/convert\";\n\nconst colorModel: ColorModel<string> = {\n  defaultColor: \"hsla(0, 0%, 0%, 1)\",\n  toHsva: hslaStringToHsva,\n  fromHsva: hsvaToHslaString,\n  equal: equalColorString,\n};\n\nexport const HslaStringColorPicker = (\n  props: Partial<ColorPickerBaseProps<string>>\n): JSX.Element => <AlphaColorPicker {...props} colorModel={colorModel} />;\n","import React from \"react\";\n\nimport { ColorPicker } from \"./common/ColorPicker\";\nimport { ColorModel, ColorPickerBaseProps, HslColor } from \"../types\";\nimport { equalColorObjects } from \"../utils/compare\";\nimport { hslaToHsva, hsvaToHsla, hslaToHsl } from \"../utils/convert\";\n\nconst colorModel: ColorModel<HslColor> = {\n  defaultColor: { h: 0, s: 0, l: 0 },\n  toHsva: ({ h, s, l }) => hslaToHsva({ h, s, l, a: 1 }),\n  fromHsva: (hsva) => hslaToHsl(hsvaToHsla(hsva)),\n  equal: equalColorObjects,\n};\n\nexport const HslColorPicker = (props: Partial<ColorPickerBaseProps<HslColor>>): JSX.Element => (\n  <ColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { ColorPicker } from \"./common/ColorPicker\";\nimport { ColorModel, ColorPickerBaseProps } from \"../types\";\nimport { equalColorString } from \"../utils/compare\";\nimport { hslStringToHsva, hsvaToHslString } from \"../utils/convert\";\n\nconst colorModel: ColorModel<string> = {\n  defaultColor: \"hsl(0, 0%, 0%)\",\n  toHsva: hslStringToHsva,\n  fromHsva: hsvaToHslString,\n  equal: equalColorString,\n};\n\nexport const HslStringColorPicker = (props: Partial<ColorPickerBaseProps<string>>): JSX.Element => (\n  <ColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { AlphaColorPicker } from \"./common/AlphaColorPicker\";\nimport { ColorModel, ColorPickerBaseProps, HsvaColor } from \"../types\";\nimport { equalColorObjects } from \"../utils/compare\";\nimport { roundHsva } from \"../utils/convert\";\n\nconst colorModel: ColorModel<HsvaColor> = {\n  defaultColor: { h: 0, s: 0, v: 0, a: 1 },\n  toHsva: (hsva) => hsva,\n  fromHsva: roundHsva,\n  equal: equalColorObjects,\n};\n\nexport const HsvaColorPicker = (props: Partial<ColorPickerBaseProps<HsvaColor>>): JSX.Element => (\n  <AlphaColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { AlphaColorPicker } from \"./common/AlphaColorPicker\";\nimport { ColorModel, ColorPickerBaseProps } from \"../types\";\nimport { equalColorString } from \"../utils/compare\";\nimport { hsvaStringToHsva, hsvaToHsvaString } from \"../utils/convert\";\n\nconst colorModel: ColorModel<string> = {\n  defaultColor: \"hsva(0, 0%, 0%, 1)\",\n  toHsva: hsvaStringToHsva,\n  fromHsva: hsvaToHsvaString,\n  equal: equalColorString,\n};\n\nexport const HsvaStringColorPicker = (\n  props: Partial<ColorPickerBaseProps<string>>\n): JSX.Element => <AlphaColorPicker {...props} colorModel={colorModel} />;\n","import React from \"react\";\n\nimport { ColorPicker } from \"./common/ColorPicker\";\nimport { ColorModel, ColorPickerBaseProps, HsvColor } from \"../types\";\nimport { equalColorObjects } from \"../utils/compare\";\nimport { hsvaToHsv } from \"../utils/convert\";\n\nconst colorModel: ColorModel<HsvColor> = {\n  defaultColor: { h: 0, s: 0, v: 0 },\n  toHsva: ({ h, s, v }) => ({ h, s, v, a: 1 }),\n  fromHsva: hsvaToHsv,\n  equal: equalColorObjects,\n};\n\nexport const HsvColorPicker = (props: Partial<ColorPickerBaseProps<HsvColor>>): JSX.Element => (\n  <ColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { ColorPicker } from \"./common/ColorPicker\";\nimport { ColorModel, ColorPickerBaseProps } from \"../types\";\nimport { equalColorString } from \"../utils/compare\";\nimport { hsvStringToHsva, hsvaToHsvString } from \"../utils/convert\";\n\nconst colorModel: ColorModel<string> = {\n  defaultColor: \"hsv(0, 0%, 0%)\",\n  toHsva: hsvStringToHsva,\n  fromHsva: hsvaToHsvString,\n  equal: equalColorString,\n};\n\nexport const HsvStringColorPicker = (props: Partial<ColorPickerBaseProps<string>>): JSX.Element => (\n  <ColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { AlphaColorPicker } from \"./common/AlphaColorPicker\";\nimport { ColorModel, ColorPickerBaseProps, RgbaColor } from \"../types\";\nimport { equalColorObjects } from \"../utils/compare\";\nimport { rgbaToHsva, hsvaToRgba } from \"../utils/convert\";\n\nconst colorModel: ColorModel<RgbaColor> = {\n  defaultColor: { r: 0, g: 0, b: 0, a: 1 },\n  toHsva: rgbaToHsva,\n  fromHsva: hsvaToRgba,\n  equal: equalColorObjects,\n};\n\nexport const RgbaColorPicker = (props: Partial<ColorPickerBaseProps<RgbaColor>>): JSX.Element => (\n  <AlphaColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { AlphaColorPicker } from \"./common/AlphaColorPicker\";\nimport { ColorModel, ColorPickerBaseProps } from \"../types\";\nimport { equalColorString } from \"../utils/compare\";\nimport { rgbaStringToHsva, hsvaToRgbaString } from \"../utils/convert\";\n\nconst colorModel: ColorModel<string> = {\n  defaultColor: \"rgba(0, 0, 0, 1)\",\n  toHsva: rgbaStringToHsva,\n  fromHsva: hsvaToRgbaString,\n  equal: equalColorString,\n};\n\nexport const RgbaStringColorPicker = (\n  props: Partial<ColorPickerBaseProps<string>>\n): JSX.Element => <AlphaColorPicker {...props} colorModel={colorModel} />;\n","import React from \"react\";\n\nimport { ColorPicker } from \"./common/ColorPicker\";\nimport { ColorModel, ColorPickerBaseProps, RgbColor } from \"../types\";\nimport { equalColorObjects } from \"../utils/compare\";\nimport { rgbaToHsva, hsvaToRgba, rgbaToRgb } from \"../utils/convert\";\n\nconst colorModel: ColorModel<RgbColor> = {\n  defaultColor: { r: 0, g: 0, b: 0 },\n  toHsva: ({ r, g, b }) => rgbaToHsva({ r, g, b, a: 1 }),\n  fromHsva: (hsva) => rgbaToRgb(hsvaToRgba(hsva)),\n  equal: equalColorObjects,\n};\n\nexport const RgbColorPicker = (props: Partial<ColorPickerBaseProps<RgbColor>>): JSX.Element => (\n  <ColorPicker {...props} colorModel={colorModel} />\n);\n","import React from \"react\";\n\nimport { ColorPicker } from \"./common/ColorPicker\";\nimport { ColorModel, ColorPickerBaseProps } from \"../types\";\nimport { equalColorString } from \"../utils/compare\";\nimport { rgbStringToHsva, hsvaToRgbString } from \"../utils/convert\";\n\nconst colorModel: ColorModel<string> = {\n  defaultColor: \"rgb(0, 0, 0)\",\n  toHsva: rgbStringToHsva,\n  fromHsva: hsvaToRgbString,\n  equal: equalColorString,\n};\n\nexport const RgbStringColorPicker = (props: Partial<ColorPickerBaseProps<string>>): JSX.Element => (\n  <ColorPicker {...props} colorModel={colorModel} />\n);\n","const matcher = /^#?([0-9A-F]{3,8})$/i;\n\nexport const validHex = (value: string, alpha?: boolean): boolean => {\n  const match = matcher.exec(value);\n  const length = match ? match[1].length : 0;\n\n  return (\n    length === 3 || // '#rgb' format\n    length === 6 || // '#rrggbb' format\n    (!!alpha && length === 4) || // '#rgba' format\n    (!!alpha && length === 8) // '#rrggbbaa' format\n  );\n};\n","import React, { useState, useEffect, useCallback } from \"react\";\n\nimport { useEventCallback } from \"../../hooks/useEventCallback\";\nimport { ColorInputBaseProps } from \"../../types\";\n\ninterface Props extends ColorInputBaseProps {\n  /** Blocks typing invalid characters and limits string length */\n  escape: (value: string) => string;\n  /** Checks that value is valid color string */\n  validate: (value: string) => boolean;\n  /** Processes value before displaying it in the input */\n  format?: (value: string) => string;\n  /** Processes value before sending it in `onChange` */\n  process?: (value: string) => string;\n}\n\nexport const ColorInput = (props: Props): JSX.Element => {\n  const { color = \"\", onChange, onBlur, escape, validate, format, process, ...rest } = props;\n  const [value, setValue] = useState(() => escape(color));\n  const onChangeCallback = useEventCallback<string>(onChange);\n  const onBlurCallback = useEventCallback<React.FocusEvent<HTMLInputElement>>(onBlur);\n\n  // Trigger `onChange` handler only if the input value is a valid color\n  const handleChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const inputValue = escape(e.target.value);\n      setValue(inputValue);\n      if (validate(inputValue)) onChangeCallback(process ? process(inputValue) : inputValue);\n    },\n    [escape, process, validate, onChangeCallback]\n  );\n\n  // Take the color from props if the last typed color (in local state) is not valid\n  const handleBlur = useCallback(\n    (e: React.FocusEvent<HTMLInputElement>) => {\n      if (!validate(e.target.value)) setValue(escape(color));\n      onBlurCallback(e);\n    },\n    [color, escape, validate, onBlurCallback]\n  );\n\n  // Update the local state when `color` property value is changed\n  useEffect(() => {\n    setValue(escape(color));\n  }, [color, escape]);\n\n  return (\n    <input\n      {...rest}\n      value={format ? format(value) : value}\n      spellCheck=\"false\" // the element should not be checked for spelling errors\n      onChange={handleChange}\n      onBlur={handleBlur}\n    />\n  );\n};\n","import React, { useCallback } from \"react\";\nimport { ColorInputBaseProps } from \"../types\";\n\nimport { validHex } from \"../utils/validate\";\nimport { ColorInput } from \"./common/ColorInput\";\n\ninterface HexColorInputProps extends ColorInputBaseProps {\n  /** Enables `#` prefix displaying */\n  prefixed?: boolean;\n  /** Allows `#rgba` and `#rrggbbaa` color formats */\n  alpha?: boolean;\n}\n\n/** Adds \"#\" symbol to the beginning of the string */\nconst prefix = (value: string) => \"#\" + value;\n\nexport const HexColorInput = (props: HexColorInputProps): JSX.Element => {\n  const { prefixed, alpha, ...rest } = props;\n\n  /** Escapes all non-hexadecimal characters including \"#\" */\n  const escape = useCallback(\n    (value: string) => value.replace(/([^0-9A-F]+)/gi, \"\").substring(0, alpha ? 8 : 6),\n    [alpha]\n  );\n\n  /** Validates hexadecimal strings */\n  const validate = useCallback((value: string) => validHex(value, alpha), [alpha]);\n\n  return (\n    <ColorInput\n      {...rest}\n      escape={escape}\n      format={prefixed ? prefix : undefined}\n      process={prefix}\n      validate={validate}\n    />\n  );\n};\n"],"names":["useEventCallback","handler","callbackRef","useRef","fn","value","current","clamp","number","min","max","isTouch","event","getParentWindow","node","ownerDocument","defaultView","self","getRelativePosition","touchId","rect","getBoundingClientRect","pointer","touches","i","length","identifier","getTouchPoint","left","pageX","pageXOffset","width","top","pageY","pageYOffset","height","preventDefaultMove","preventDefault","Interactive","React","memo","onMove","onKey","rest","container","onMoveCallback","onKeyCallback","hasTouch","useMemo","handleMove","buttons","toggleDocumentEvents","handleMoveEnd","state","touch","parentWindow","toggleEvent","addEventListener","removeEventListener","nativeEvent","el","isInvalid","changedTouches","focus","keyCode","which","handleMoveStart","handleKeyDown","useEffect","onTouchStart","onMouseDown","className","ref","onKeyDown","tabIndex","role","formatClassName","names","filter","Boolean","join","Pointer","color","nodeClassName","style","backgroundColor","round","digits","base","Math","pow","angleUnits","grad","turn","rad","PI","hexToHsva","hex","rgbaToHsva","hexToRgba","substring","r","parseInt","g","b","a","parseHue","unit","Number","hslaStringToHsva","hslString","match","exec","hslaToHsva","h","s","l","undefined","v","hslStringToHsva","hsvaToHex","hsva","rgbaToHex","hsvaToRgba","hsvaToHsla","hh","hsvaToHslString","hsvaToHslaString","floor","c","d","module","hsvaStringToHsva","hsvString","roundHsva","hsvStringToHsva","rgbaStringToHsva","rgbaString","rgbStringToHsva","format","toString","alphaHex","delta","Hue","hue","onChange","interaction","offset","aria-label","aria-valuenow","aria-valuemax","aria-valuemin","Saturation","containerStyle","aria-valuetext","equalColorObjects","first","second","prop","equalColorString","replace","equalHex","toLowerCase","useColorManipulation","colorModel","onChangeCallback","useState","toHsva","updateHsva","cache","equal","newHsva","newColor","fromHsva","handleChange","useCallback","params","Object","assign","nonce","useIsomorphicLayoutEffect","window","useLayoutEffect","getNonce","__webpack_nonce__","setNonce","hash","styleElementMap","Map","useStyleSheet","nodeRef","parentDocument","document","has","styleElement","createElement","innerHTML","set","setAttribute","head","appendChild","ColorPicker","defaultColor","HexColorPicker","props","Alpha","gradientStyle","backgroundImage","ariaValue","AlphaColorPicker","HexAlphaColorPicker","HslaColorPicker","HslaStringColorPicker","HslColorPicker","HslStringColorPicker","HsvaColorPicker","HsvaStringColorPicker","HsvColorPicker","HsvStringColorPicker","RgbaColorPicker","RgbaStringColorPicker","RgbColorPicker","RgbStringColorPicker","matcher","ColorInput","onBlur","escape","validate","process","setValue","onBlurCallback","e","inputValue","target","handleBlur","spellCheck","prefix","HexColorInput","prefixed","alpha","validHex"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33],"debugId":null}},
    {"offset": {"line": 7697, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Blink%400.33.1/node_modules/%40lexical/link/LexicalLink.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement, $findMatchingParent } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection, $isNodeSelection, $normalizeSelection__EXPERIMENTAL, $setSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if (isHTMLAnchorElement(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!$isElementNode(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = $getSelection();\n  if (!$isRangeSelection(initialSelection)) {\n    return $fn();\n  }\n  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = $getSelection();\n    if ($isRangeSelection(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      $setSelection($normalizeSelection__EXPERIMENTAL(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (selection === null || !$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n    return;\n  }\n  if ($isNodeSelection(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ($isElementNode(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, formatUrl, toggleLink };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8231, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Bmark%400.33.1/node_modules/%40lexical/mark/LexicalMark.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { ElementNode, $isRangeSelection, $applyNodeReplacement, $createRangeSelection, $isElementNode, $isTextNode, $isDecoratorNode } from 'lexical';\nimport { addClassNamesToElement, removeClassNamesFromElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NO_IDS = [];\n\n/** @noInheritDoc */\nclass MarkNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(node.__ids, node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    return $createMarkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIDs(serializedNode.ids);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs()\n    };\n  }\n  constructor(ids = NO_IDS, key) {\n    super(key);\n    this.__ids = ids;\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    addClassNamesToElement(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      addClassNamesToElement(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    return this.getIDs().includes(id);\n  }\n  getIDs() {\n    return Array.from(this.getLatest().__ids);\n  }\n  setIDs(ids) {\n    const self = this.getWritable();\n    self.__ids = ids;\n    return self;\n  }\n  addID(id) {\n    const self = this.getWritable();\n    return self.__ids.includes(id) ? self : self.setIDs([...self.__ids, id]);\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    const idx = self.__ids.indexOf(id);\n    if (idx === -1) {\n      return self;\n    }\n    const ids = Array.from(self.__ids);\n    ids.splice(idx, 1);\n    return self.setIDs(ids);\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids = NO_IDS) {\n  return $applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  // Force a forwards selection since append is used, ignore the argument.\n  // A new selection is used to avoid side-effects of flipping the given\n  // selection\n  const forwardSelection = $createRangeSelection();\n  const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n  forwardSelection.anchor.set(startPoint.key, startPoint.offset, startPoint.type);\n  forwardSelection.focus.set(endPoint.key, endPoint.offset, endPoint.type);\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // Note that extract will split text nodes at the boundaries\n  const nodes = forwardSelection.extract();\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (const node of nodes) {\n    if ($isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    let targetNode = null;\n    if ($isTextNode(node)) {\n      // Case 1: The node is a text node and we can include it\n      targetNode = node;\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may ultimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (($isElementNode(node) || $isDecoratorNode(node)) && node.isInline()) {\n      // Case 3: inline element/decorator nodes can be added in their entirety\n      // to the new mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ($isElementNode(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ($isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\nexport { $createMarkNode, $getMarkIDs, $isMarkNode, $unwrapMarkNode, $wrapSelectionInMarkNode, MarkNode };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8489, "column": 0}, "map": {"version":3,"sources":["file:///Users/silsmaria/Projects/mathview/node_modules/.pnpm/%40lexical%2Bdevtools-core%400.33.1_react-dom%4019.1.0_react%4019.1.0__react%4019.1.0/node_modules/%40lexical/devtools-core/LexicalDevtoolsCore.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes } from '@lexical/html';\nimport { $isLinkNode } from '@lexical/link';\nimport { $isMarkNode } from '@lexical/mark';\nimport { $isTableSelection } from '@lexical/table';\nimport { $getSelection, $getRoot, $isRangeSelection, $isNodeSelection, $isElementNode, $isTextNode, $isParagraphNode, COMMAND_PRIORITY_CRITICAL } from 'lexical';\nimport { forwardRef, useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { jsxs, jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '',\n  isLastChild: '',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline', node => node.hasFormat('highlight') && 'Highlight'];\nconst FORMAT_PREDICATES_PARAGRAPH = [node => node.hasTextFormat('bold') && 'Bold', node => node.hasTextFormat('code') && 'Code', node => node.hasTextFormat('italic') && 'Italic', node => node.hasTextFormat('strikethrough') && 'Strikethrough', node => node.hasTextFormat('subscript') && 'Subscript', node => node.hasTextFormat('superscript') && 'Superscript', node => node.hasTextFormat('underline') && 'Underline', node => node.hasTextFormat('highlight') && 'Highlight'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\nfunction generateContent(editor, commandsLog, exportDOM, customPrintNode, obfuscateText = false) {\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML($generateHtmlFromNodes(editor));\n    });\n    return htmlString;\n  }\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = $getSelection();\n    visitTree($getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${printNode(node, customPrintNode, obfuscateText)}\\n`;\n      res += $printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : $isRangeSelection(selection) ? printRangeSelection(selection) : $isTableSelection(selection) ? printTableSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n  if (commandsLog.length) {\n    for (const {\n      index,\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n   ${index}. { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n   None dispatched.';\n  }\n  const {\n    version\n  } = editor.constructor;\n  res += `\\n\\n editor${version ? ` (v${version})` : ''}:`;\n  res += `\\n   namespace ${editorConfig.namespace}`;\n  if (compositionKey !== null) {\n    res += `\\n   compositionKey ${compositionKey}`;\n  }\n  res += `\\n   editable ${String(editable)}`;\n  return res;\n}\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n   anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n   focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\nfunction printNodeSelection(selection) {\n  if (!$isNodeSelection(selection)) {\n    return '';\n  }\n  return `: node\\n   [${Array.from(selection._nodes).join(', ')}]`;\n}\nfunction printTableSelection(selection) {\n  return `: table\\n   { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n    if ($isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\nfunction normalize(text, obfuscateText = false) {\n  const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n  if (obfuscateText) {\n    return textToPrint.replace(/[^\\s]/g, '*');\n  }\n  return textToPrint;\n}\nfunction printNode(node, customPrintNode, obfuscateText = false) {\n  const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : undefined;\n  if (customPrint !== undefined && customPrint.length > 0) {\n    return customPrint;\n  }\n  if ($isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text, obfuscateText)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ($isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link, obfuscateText)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ($isMarkNode(node)) {\n    return `ids: [ ${node.getIDs().join(', ')} ]`;\n  } else if ($isParagraphNode(node)) {\n    const formatText = printTextFormatProperties(node);\n    let paragraphData = formatText !== '' ? `{ ${formatText} }` : '';\n    paragraphData += node.__style ? `(${node.__style})` : '';\n    return paragraphData;\n  } else {\n    return '';\n  }\n}\nfunction printTextFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES_PARAGRAPH.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node), printStateProperties(node)].filter(Boolean).join(', ');\n}\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node), printStateProperties(node)].filter(Boolean).join(', ');\n}\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n  return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n  return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printTargetProperties(node) {\n  let str = node.getTarget();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n  return str;\n}\nfunction printRelProperties(node) {\n  let str = node.getRel();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n  return str;\n}\nfunction printTitleProperties(node) {\n  let str = node.getTitle();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n  return str;\n}\nfunction printStateProperties(node) {\n  if (!node.__state) {\n    return false;\n  }\n  const states = [];\n  for (const [stateType, value] of node.__state.knownState.entries()) {\n    if (stateType.isEqual(value, stateType.defaultValue)) {\n      continue;\n    }\n    const textValue = JSON.stringify(stateType.unparse(value));\n    states.push(`[${stateType.key}: ${textValue}]`);\n  }\n  let str = states.join(',');\n  if (str !== '') {\n    str = 'state: ' + str;\n  }\n  return str;\n}\nfunction $printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!$isTextNode(node) || !$isRangeSelection(selection) || !isSelected || $isElementNode(node)) {\n    return '';\n  }\n\n  // No selected characters.\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n  const [start, end] = $getSelectionStartEnd(node, selection);\n  if (start === end) {\n    return '';\n  }\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 2; // 1 for the space after + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n  return node;\n}\nfunction $getSelectionStartEnd(node, selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if ($isNodeSelection(selection) || anchorAndFocus === null) {\n    return [-1, -1];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1;\n\n  // Only one node is being selected.\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  }\n\n  // Account for non-single width characters.\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LARGE_EDITOR_STATE_SIZE = 1000;\nconst TreeView = /*#__PURE__*/forwardRef(function TreeViewWrapped({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editorState,\n  setEditorState,\n  setEditorReadOnly,\n  generateContent,\n  commandsLog = []\n}, ref) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = useState([]);\n  const [content, setContent] = useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = useState(false);\n  const [showExportDOM, setShowExportDOM] = useState(false);\n  const playingIndexRef = useRef(0);\n  const inputRef = useRef(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isLimited, setIsLimited] = useState(false);\n  const [showLimited, setShowLimited] = useState(false);\n  const lastEditorStateRef = useRef();\n  const lastCommandsLogRef = useRef([]);\n  const lastGenerationID = useRef(0);\n  const generateTree = useCallback(exportDOM => {\n    const myID = ++lastGenerationID.current;\n    generateContent(exportDOM).then(treeText => {\n      if (myID === lastGenerationID.current) {\n        setContent(treeText);\n      }\n    }).catch(err => {\n      if (myID === lastGenerationID.current) {\n        setContent(`Error rendering tree: ${err.message}\\n\\nStack:\\n${err.stack}`);\n      }\n    });\n  }, [generateContent]);\n  useEffect(() => {\n    if (!showLimited && editorState._nodeMap.size > LARGE_EDITOR_STATE_SIZE) {\n      setIsLimited(true);\n      if (!showLimited) {\n        return;\n      }\n    }\n\n    // Update view when either editor state changes or new commands are logged\n    const shouldUpdate = lastEditorStateRef.current !== editorState || lastCommandsLogRef.current !== commandsLog;\n    if (shouldUpdate) {\n      // Check if it's a real editor state change\n      const isEditorStateChange = lastEditorStateRef.current !== editorState;\n      lastEditorStateRef.current = editorState;\n      lastCommandsLogRef.current = commandsLog;\n      generateTree(showExportDOM);\n\n      // Only record in time travel if there was an actual editor state change\n      if (!timeTravelEnabled && isEditorStateChange) {\n        setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n      }\n    }\n  }, [editorState, generateTree, showExportDOM, showLimited, timeTravelEnabled, commandsLog]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, totalEditorStates, setEditorState]);\n  const handleExportModeToggleClick = () => {\n    generateTree(!showExportDOM);\n    setShowExportDOM(!showExportDOM);\n  };\n  return /*#__PURE__*/jsxs(\"div\", {\n    className: viewClassName,\n    children: [!showLimited && isLimited ? /*#__PURE__*/jsxs(\"div\", {\n      style: {\n        padding: 20\n      },\n      children: [/*#__PURE__*/jsx(\"span\", {\n        style: {\n          marginRight: 20\n        },\n        children: \"Detected large EditorState, this can impact debugging performance.\"\n      }), /*#__PURE__*/jsx(\"button\", {\n        onClick: () => {\n          setShowLimited(true);\n        },\n        style: {\n          background: 'transparent',\n          border: '1px solid white',\n          color: 'white',\n          cursor: 'pointer',\n          padding: 5\n        },\n        children: \"Show full tree\"\n      })]\n    }) : null, !showLimited ? /*#__PURE__*/jsx(\"button\", {\n      onClick: () => handleExportModeToggleClick(),\n      className: treeTypeButtonClassName,\n      type: \"button\",\n      children: showExportDOM ? 'Tree' : 'Export DOM'\n    }) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/jsx(\"button\", {\n      onClick: () => {\n        setEditorReadOnly(true);\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      },\n      className: timeTravelButtonClassName,\n      type: \"button\",\n      children: \"Time Travel\"\n    }), (showLimited || !isLimited) && /*#__PURE__*/jsx(\"pre\", {\n      ref: ref,\n      children: content\n    }), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/jsxs(\"div\", {\n      className: timeTravelPanelClassName,\n      children: [/*#__PURE__*/jsx(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          if (playingIndexRef.current === totalEditorStates - 1) {\n            playingIndexRef.current = 1;\n          }\n          setIsPlaying(!isPlaying);\n        },\n        type: \"button\",\n        children: isPlaying ? 'Pause' : 'Play'\n      }), /*#__PURE__*/jsx(\"input\", {\n        className: timeTravelPanelSliderClassName,\n        ref: inputRef,\n        onChange: event => {\n          const editorStateIndex = Number(event.target.value);\n          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n          if (timeStampedEditorState) {\n            playingIndexRef.current = editorStateIndex;\n            setEditorState(timeStampedEditorState[1]);\n          }\n        },\n        type: \"range\",\n        min: \"1\",\n        max: totalEditorStates - 1\n      }), /*#__PURE__*/jsx(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          setEditorReadOnly(false);\n          const index = timeStampedEditorStates.length - 1;\n          const timeStampedEditorState = timeStampedEditorStates[index];\n          setEditorState(timeStampedEditorState[1]);\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setTimeTravelEnabled(false);\n          setIsPlaying(false);\n        },\n        type: \"button\",\n        children: \"Exit\"\n      })]\n    })]\n  });\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerLexicalCommandLogger(editor, setLoggedCommands) {\n  const unregisterCommandListeners = new Set();\n  let i = 0;\n  for (const [command] of editor._commands) {\n    unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n      setLoggedCommands(state => {\n        i += 1;\n        const newState = [...state];\n        newState.push({\n          index: i,\n          payload,\n          type: command.type ? command.type : 'UNKNOWN'\n        });\n        if (newState.length > 10) {\n          newState.shift();\n        }\n        return newState;\n      });\n      return false;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  return () => unregisterCommandListeners.forEach(unregister => unregister());\n}\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = useState([]);\n  useEffect(() => {\n    return registerLexicalCommandLogger(editor, setLoggedCommands);\n  }, [editor]);\n  return useMemo(() => loggedCommands, [loggedCommands]);\n}\n\nexport { TreeView, generateContent, registerLexicalCommandLogger, useLexicalCommandsLog };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}